def build_analysis_matrix(df: pd.DataFrame) -> tuple[pd.DataFrame, list[str]]:
    """
    Build a numeric feature matrix from FEATURES_FOR_ANALYSIS.

    - Numeric features are used as-is.
    - Categorical features are one-hot encoded (get_dummies), with column
      names like "Capability_A", "Capability_B", etc.
    - Returns:
        X   : DataFrame (rows = runs, columns = numeric / one-hot features)
        cols: list of column labels corresponding to X.columns
    """
    matrices = []
    labels: list[str] = []

    for feat in FEATURES_FOR_ANALYSIS:
        if feat not in df.columns:
            continue
        s = df[feat]
        # Numeric: use directly
        if np.issubdtype(s.dtype, np.number):
            matrices.append(s.astype(float).to_frame())
            labels.append(feat)
        else:
            # Categorical: one-hot encode
            dummies = pd.get_dummies(s.astype(str), prefix=feat)
            if not dummies.empty:
                matrices.append(dummies.astype(float))
                labels.extend(dummies.columns.tolist())

    if not matrices:
        return pd.DataFrame(index=df.index), []

    X = pd.concat(matrices, axis=1)
    return X, labels



=========================================================================================================================================================================
=========================================================================================================================================================================
def zscore_matrix(df: pd.DataFrame) -> tuple[pd.DataFrame, list[str]]:
    """
    Compute z-scores for the numeric / one-hot encoded matrix derived from
    FEATURES_FOR_ANALYSIS.

    Returns:
      Z     : DataFrame of z-scores (same shape as analysis matrix)
      labels: list of column names used in Z
    """
    X, labels = build_analysis_matrix(df)
    if X.empty:
        return X, labels

    mu = X.mean(axis=0)
    sd = X.std(axis=0).replace(0, 1.0)
    Z = (X - mu) / sd
    return Z, labels


=========================================================================================================================================================================
=========================================================================================================================================================================
def segment_diff_bar(df: pd.DataFrame) -> go.Figure:
    """
    Compare Low-FR vs High-FR segments for all features in FEATURES_FOR_ANALYSIS.

    - For numeric features: difference in z-score (High − Low).
    - For categorical features: difference in one-hot z-score per category.
      (Bars will be labeled like "Capability_A", "Capability_B", etc.)
    """
    fig = go.Figure()

    # Build FR segments
    seg = make_fr_segments(df)  # "Low FR" / "Mid FR" / "High FR"
    Z, labels = zscore_matrix(df)
    if Z.empty or not labels:
        fig.update_layout(
            title="Feature Difference (configure FEATURES_FOR_ANALYSIS)",
            height=200,
            margin=dict(l=10, r=10, t=40, b=40),
        )
        return fig

    low = Z[seg == "Low FR"].mean()
    high = Z[seg == "High FR"].mean()
    diff = (high - low).sort_values(key=lambda s: s.abs(), ascending=False)

    fig.add_bar(x=diff.index, y=diff.values)
    fig.update_layout(
        title="Feature Difference (High FR − Low FR) [z-score]",
        xaxis_title="Feature / Category (one-hot)",
        yaxis_title="Δ z-score (higher ⇒ higher in High-FR segment)",
        height=360,
        margin=dict(l=10, r=10, t=40, b=60),
    )
    return fig


=========================================================================================================================================================================
=========================================================================================================================================================================
def fr_correlation_heatmap(df: pd.DataFrame) -> go.Figure:
    """
    Show correlation of each numeric / one-hot encoded feature with FR.

    - Uses the analysis matrix (numeric + one-hot).
    - FR must be present and numeric.
    """
    fig = go.Figure()

    if "FR" not in df.columns or not np.issubdtype(df["FR"].dtype, np.number):
        fig.update_layout(
            title="Correlation with FR (FR missing or non-numeric)",
            height=200,
            margin=dict(l=10, r=10, t=40, b=40),
        )
        return fig

    X, labels = build_analysis_matrix(df)
    if X.empty or not labels:
        fig.update_layout(
            title="Correlation with FR (configure FEATURES_FOR_ANALYSIS)",
            height=200,
            margin=dict(l=10, r=10, t=40, b=40),
        )
        return fig

    # Standardizing isn't necessary for correlation, but harmless.
    corr_df = pd.concat([X, df["FR"]], axis=1).corr()
    corr = corr_df.loc[labels, ["FR"]].round(3)

    fig.add_trace(
        go.Heatmap(
            z=corr.values.T,
            x=corr.index.tolist(),
            y=["FR"],
            text=corr.values.T,
            texttemplate="%{text}",
            zmin=-1,
            zmax=1,
            colorbar=dict(title="corr"),
        )
    )
    fig.update_layout(
        title="Correlation with FR",
        height=220,
        margin=dict(l=10, r=10, t=40, b=10),
    )
    return fig


=========================================================================================================================================================================
=========================================================================================================================================================================

def per_point_contribution_bar(df: pd.DataFrame, row_pos: int) -> go.Figure:
    """
    For a selected run (row_pos), show the top-5 deviations (z-scores) across
    all analysis features (numeric + one-hot encoded).

    Bars may be labeled by:
      - base numeric features (e.g., "FR", "Num_Tests"), or
      - one-hot encoded categories (e.g., "Capability_A", "Simulation_Host_node1").
    """
    fig = go.Figure()
    Z, labels = zscore_matrix(df)
    if Z.empty or not labels:
        fig.update_layout(
            title="Why this run? (configure FEATURES_FOR_ANALYSIS)",
            height=200,
            margin=dict(l=10, r=10, t=40, b=40),
        )
        return fig

    if row_pos < 0 or row_pos >= len(Z):
        row_pos = 0

    # Use signed z-scores; rank by absolute deviation
    row_z = Z.iloc[row_pos]
    top = row_z.abs().sort_values(ascending=False).head(5)
    signed = row_z[top.index]

    fig.add_trace(go.Bar(x=top.index.tolist(), y=signed.values))
    fig.update_layout(
        title="Why this run? Top deviations (z-scores)",
        xaxis_title="Feature / Category (one-hot)",
        yaxis_title="Deviation (±σ)",
        height=300,
        margin=dict(l=10, r=10, t=40, b=40),
    )
    return fig


=========================================================================================================================================================================
=========================================================================================================================================================================

def add_pca_loadings_3d(
    fig: go.Figure,
    pca,
    feature_names: list[str],
    scale: float = 2.0,
):
    """
    Overlay PCA loading arrows (global biplot) for first 2–3 PCs.

    feature_names must correspond to the numeric features used to fit the PCA.
    """
    loadings = getattr(pca, "components_", None)
    if loadings is None:
        return fig
    loadings = loadings.T  # shape: (n_features, n_components)
    k = min(3, loadings.shape[1])
    if k < 2:
        return fig

    # Try to align by feature_names_in_ if available
    base_names = list(getattr(pca, "feature_names_in_", []))
    indices = []
    labels = []
    if base_names:
        for fname in feature_names:
            if fname in base_names:
                i = base_names.index(fname)
                if i < loadings.shape[0]:
                    indices.append(i)
                    labels.append(fname)
    else:
        # Fallback: assume same order as feature_names
        for i, fname in enumerate(feature_names):
            if i < loadings.shape[0]:
                indices.append(i)
                labels.append(fname)

    for idx, fname in zip(indices, labels):
        vec = loadings[idx, :k] * scale
        if k >= 3:
            x, y, z = [0, float(vec[0])], [0, float(vec[1])], [0, float(vec[2])]
            fig.add_trace(
                go.Scatter3d(
                    x=x,
                    y=y,
                    z=z,
                    mode="lines",
                    line=dict(width=5),
                    name=f"→ {fname}",
                    showlegend=False,
                )
            )
            fig.add_trace(
                go.Scatter3d(
                    x=[x[-1]],
                    y=[y[-1]],
                    z=[z[-1]],
                    mode="text",
                    text=[fname],
                    showlegend=False,
                )
            )
        else:
            x, y = [0, float(vec[0])], [0, float(vec[1])]
            fig.add_trace(
                go.Scatter(
                    x=x,
                    y=y,
                    mode="lines+text",
                    text=[None, fname],
                    textposition="top center",
                    showlegend=False,
                )
            )
    return fig


=========================================================================================================================================================================
=========================================================================================================================================================================

def add_biplot_arrows_at_anchor_3d(
    fig: go.Figure,
    pca,
    feature_names: list[str],
    anchor: np.ndarray,
    *,
    scale: float = 1.5,
    color: str | None = None,
    name_prefix: str = "",
    showlegend: bool = False,
):
    """
    Draw PCA loading arrows anchored at a specified 3D point (anchor).

    Used to place the same global PCA directions near, e.g., Low-FR or High-FR
    centroids so users can see "which direction increases what" in each band.
    """
    loadings = getattr(pca, "components_", None)
    if loadings is None:
        return fig
    loadings = loadings.T
    k = min(3, loadings.shape[1])
    if k < 2:
        return fig

    base_names = list(getattr(pca, "feature_names_in_", []))
    indices = []
    labels = []
    if base_names:
        for fname in feature_names:
            if fname in base_names:
                i = base_names.index(fname)
                if i < loadings.shape[0]:
                    indices.append(i)
                    labels.append(fname)
    else:
        for i, fname in enumerate(feature_names):
            if i < loadings.shape[0]:
                indices.append(i)
                labels.append(fname)

    ax, ay, az = (
        (float(anchor[0]), float(anchor[1]), float(anchor[2]))
        if len(anchor) >= 3
        else (float(anchor[0]), float(anchor[1]), 0.0)
    )

    for idx, fname in zip(indices, labels):
        vec = loadings[idx, :k] * scale
        if k >= 3:
            x = [ax, ax + float(vec[0])]
            y = [ay, ay + float(vec[1])]
            z = [az, az + float(vec[2])]
            fig.add_trace(
                go.Scatter3d(
                    x=x,
                    y=y,
                    z=z,
                    mode="lines",
                    line=dict(width=4, color=color) if color else dict(width=4),
                    name=f"{name_prefix}→ {fname}",
                    showlegend=showlegend,
                )
            )
            fig.add_trace(
                go.Scatter3d(
                    x=[x[-1]],
                    y=[y[-1]],
                    z=[z[-1]],
                    mode="text",
                    text=[fname],
                    textposition="top center",
                    showlegend=False,
                )
            )
        else:
            x = [ax, ax + float(vec[0])]
            y = [ay, ay + float(vec[1])]
            fig.add_trace(
                go.Scatter(
                    x=x,
                    y=y,
                    mode="lines+text",
                    text=[None, f"{name_prefix}→ {fname}"],
                    textposition="top center",
                    line=dict(width=4, color=color) if color else dict(width=4),
                    showlegend=showlegend,
                )
            )
    return fig


=========================================================================================================================================================================
=========================================================================================================================================================================

def _render_table_and_plot(
    df: pd.DataFrame,
    PCs: np.ndarray,
    scores01: np.ndarray,
    raw_scores: np.ndarray,
    method_label: str,
    key_prefix: str,
    pca,  # global PCA (for loadings)
):
    """
    Renders:
      1) Top anomalies table with row selection
      2) PCA scatter with optional highlight + PCA loading arrows (global + segment-anchored)
      3) Segment Comparison & FR correlation panels (optional)
      4) Per-selection 'Why this run?' panel (optional)
    """
    df = df.copy()
    df["anomaly_score"] = scores01
    df["raw_anomaly_score"] = raw_scores

    st.markdown(f"### {method_label}")

    # --- Top anomalies: select a row to highlight on the plot ---
    highlight_pos = None
    if show_top > 0:
        cols_keep = [
            "Test_Run_ID", "FR", "Num_Tests", "total_init_time",
            "anomaly_score", "raw_anomaly_score",
            "Simulation_Host", "Simulation_Node", "Capability",
            "Script_File", "V", "s_number", "Build",
        ]
        cols_keep = [c for c in cols_keep if c in df.columns]

        top = df.sort_values("anomaly_score", ascending=False).head(show_top)

        st.markdown("**Top anomalies**")
        editable = top[cols_keep].copy()
        editable.insert(0, "Select", False)

        edited = st.data_editor(
            editable,
            use_container_width=True,
            num_rows="fixed",
            disabled={c: True for c in editable.columns if c != "Select"},
            key=f"{key_prefix}-table",
        )

        selected_original_idxs = edited.index[edited["Select"]].tolist()
        if selected_original_idxs:
            pos = df.index.get_indexer([selected_original_idxs[0]])
            if len(pos) and pos[0] != -1:
                highlight_pos = int(pos[0])

    # --- PCA plot with optional highlight ---
    fig = plot_for_df(df, PCs, label_choice, highlight_pos=highlight_pos)

    # === Driver arrows overlays ===
    if show_biplot and PCs.shape[1] >= 2 and pca is not None:
        # 1) Global arrows from origin
        try:
            add_pca_loadings_3d(fig, pca, PCA_FEATURES, scale=2.0)
        except Exception:
            pass

        # 2) Segment-anchored arrows near Low-FR and High-FR bands
        try:
            seg = make_fr_segments(df)  # "Low FR" / "Mid FR" / "High FR"
            # Low-FR centroid
            low_mask = (seg == "Low FR").values
            if np.any(low_mask):
                low_anchor = PCs[low_mask].mean(axis=0)
                add_biplot_arrows_at_anchor_3d(
                    fig,
                    pca,
                    PCA_FEATURES,
                    low_anchor,
                    scale=1.2,
                    color="green",
                    name_prefix="Low FR ",
                    showlegend=False,
                )
            # High-FR centroid
            high_mask = (seg == "High FR").values
            if np.any(high_mask):
                high_anchor = PCs[high_mask].mean(axis=0)
                add_biplot_arrows_at_anchor_3d(
                    fig,
                    pca,
                    PCA_FEATURES,
                    high_anchor,
                    scale=1.2,
                    color="red",
                    name_prefix="High FR ",
                    showlegend=False,
                )
        except Exception:
            pass

    st.plotly_chart(fig, use_container_width=True, key=f"{key_prefix}-plot")

    # --- Segment Comparison + FR Correlation ---
    if show_segment_compare:
        c1, c2 = st.columns([2, 1])
        with c1:
            st.markdown("#### Segment Comparison: Low vs High FR")
            st.plotly_chart(
                segment_diff_bar(df),
                use_container_width=True,
                key=f"{key_prefix}-segdiff",
            )
        with c2:
            st.markdown("#### FR Correlation")
            st.plotly_chart(
                fr_correlation_heatmap(df),
                use_container_width=True,
                key=f"{key_prefix}-frcorr",
            )

    # --- Per-selection “Why this run?” ---
    if show_selection_why and highlight_pos is not None:
        st.markdown("#### Why this run?")
        st.plotly_chart(
            per_point_contribution_bar(df, highlight_pos),
            use_container_width=True,
            key=f"{key_prefix}-whybar",
        )


