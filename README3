# === Influence Network (Anomaly co-movement) ===
st.sidebar.subheader("Anomaly Influence Network")

show_influence_network = st.sidebar.checkbox(
    "Show Anomaly Influence Network",
    value=True,
    key="show_influence_network",
)

influence_subset = st.sidebar.selectbox(
    "Subset",
    ["Anomalous (top 5%)", "Normal (bottom 5%)", "All runs"],
    index=0,
    key="influence_subset",
)

influence_topk = st.sidebar.slider(
    "Top-K features",
    min_value=4, max_value=15, value=10, step=1,
    key="influence_topk",
)

influence_edge_thresh = st.sidebar.slider(
    "Edge threshold (|corr|)",
    min_value=0.10, max_value=0.90, value=0.40, step=0.05,
    key="influence_edge_thresh",
)

influence_corr_method = st.sidebar.selectbox(
    "Correlation method",
    ["pearson", "spearman"],
    index=0,
    key="influence_corr_method",
)



=========================================================================================================================================================================
=========================================================================================================================================================================
def anomaly_influence_network_figure(
    df: pd.DataFrame,
    scores01: np.ndarray,
    *,
    subset: str = "Anomalous (top 5%)",
    q: float = 0.95,
    top_k: int = 10,
    edge_thresh: float = 0.40,
    corr_method: str = "pearson",
) -> go.Figure:
    """
    Build a feature co-movement network among the top-K features most responsible
    for anomalies. Nodes = features; edges = |correlation| among selected subset.
    Node color = mean z-score (subset); node size = variance (subset).
    """
    fig = go.Figure()

    # Build numeric/one-hot analysis matrix from FEATURES_FOR_ANALYSIS
    Z, labels = zscore_matrix(df)  # Z is standardized (z-scores)
    if Z.empty or not labels:
        fig.update_layout(
            title="Influence Network (configure FEATURES_FOR_ANALYSIS)",
            height=220, margin=dict(l=10, r=10, t=40, b=40),
        )
        return fig

    # Choose subset mask
    if subset.startswith("Anomalous"):
        thr = np.nanpercentile(scores01, 100 * q)
        mask = scores01 >= thr
        subset_name = "Anomalous"
    elif subset.startswith("Normal"):
        thr = np.nanpercentile(scores01, 100 * (1 - q))
        mask = scores01 <= thr
        subset_name = "Normal"
    else:
        mask = np.ones(len(Z), dtype=bool)
        subset_name = "All runs"

    Zs = Z.loc[mask]
    if Zs.shape[0] < 3:
        fig.update_layout(
            title=f"Influence Network ({subset_name}: not enough rows)",
            height=220, margin=dict(l=10, r=10, t=40, b=40),
        )
        return fig

    # Feature importance = variance within the subset (how much the feature varies among selected runs)
    imp = Zs.var(axis=0)  # already standardized, so variance is an effect size
    imp = imp.replace([np.inf, -np.inf], np.nan).fillna(0.0)

    # Pick top-K features by importance
    top_feats = imp.sort_values(ascending=False).head(top_k).index.tolist()
    Zk = Zs[top_feats]

    # Node color = mean z-score in subset (how high/low feature is on average)
    node_color = Zk.mean(axis=0)  # signed
    # Node size = scaled importance
    imp_vals = imp[top_feats].values
    if np.nanmax(imp_vals) <= 0:
        sizes = np.full_like(imp_vals, 20.0, dtype=float)
    else:
        sizes = 20 + 40 * (imp_vals / np.nanmax(imp_vals))  # 20..60

    # Correlation among top-K features within subset
    corr = Zk.corr(method=corr_method).fillna(0.0)

    # Layout: place nodes on a circle (stable & simple)
    n = len(top_feats)
    angles = np.linspace(0, 2 * np.pi, n, endpoint=False)
    radius = 1.0
    xs = radius * np.cos(angles)
    ys = radius * np.sin(angles)
    pos = {feat: (float(x), float(y)) for feat, x, y in zip(top_feats, xs, ys)}

    # Edges: add lines where |corr| >= edge_thresh; color by sign
    for i in range(n):
        for j in range(i + 1, n):
            f1, f2 = top_feats[i], top_feats[j]
            c = corr.loc[f1, f2]
            if np.isnan(c) or abs(c) < edge_thresh:
                continue
            x0, y0 = pos[f1]
            x1, y1 = pos[f2]
            fig.add_trace(
                go.Scatter(
                    x=[x0, x1], y=[y0, y1],
                    mode="lines",
                    line=dict(
                        width=2 + 4 * abs(c),  # thicker = stronger
                        color="red" if c > 0 else "blue",
                    ),
                    hoverinfo="text",
                    text=[f"{f1} ↔ {f2}: corr={c:.2f}"] * 2,
                    showlegend=False,
                )
            )

    # Nodes
    fig.add_trace(
        go.Scatter(
            x=[pos[f][0] for f in top_feats],
            y=[pos[f][1] for f in top_feats],
            mode="markers+text",
            text=top_feats,
            textposition="top center",
            hoverinfo="text",
            marker=dict(
                size=sizes.tolist(),
                color=node_color.values.tolist(),
                colorscale="RdBu",
                cmin=-np.nanmax(np.abs(node_color.values)) if np.nanmax(np.abs(node_color.values)) > 0 else -1,
                cmax= np.nanmax(np.abs(node_color.values)) if np.nanmax(np.abs(node_color.values)) > 0 else 1,
                colorbar=dict(title="mean z (subset)"),
                line=dict(width=1, color="#444"),
            ),
            showlegend=False,
        )
    )

    fig.update_layout(
        title=f"Anomaly Influence Network — {subset_name} subset "
              f"(Top-{top_k}, edges |corr|≥{edge_thresh:.2f})",
        xaxis=dict(visible=False),
        yaxis=dict(visible=False),
        height=520,
        margin=dict(l=10, r=10, t=60, b=10),
    )
    return fig



=========================================================================================================================================================================
=========================================================================================================================================================================

def _render_table_and_plot(
    df: pd.DataFrame,
    PCs: np.ndarray,
    scores01: np.ndarray,
    raw_scores: np.ndarray,
    method_label: str,
    key_prefix: str,
    pca,                  # global PCA (for loadings)
    pca_arrow_features: list[str],  # user-selected PCA features for arrows
):
    """
    Renders:
      1) Top anomalies table with row selection
      2) PCA scatter with optional highlight + PCA loading arrows
         (global + segment-anchored; subset controlled by pca_arrow_features
          and by which clusters the user chooses to display)
      3) Segment Comparison + FR correlation below the PCA plot
      4) Anomaly Influence Network (optional)
      5) Per-selection 'Why this run?' panel at the bottom
    """
    df = df.copy()
    df["anomaly_score"] = scores01
    df["raw_anomaly_score"] = raw_scores

    st.markdown(f"### {method_label}")

    # --- Top anomalies: select a row to highlight on the plot ---
    highlight_pos = None
    if show_top > 0:
        cols_keep = [
            "Test_Run_ID",
            "FR",
            "Num_Tests",
            "total_init_time",
            "anomaly_score",
            "raw_anomaly_score",
            "Simulation_Host",
            "Simulation_Node",
            "Capability",
            "Script_File",
            "V",
            "s_number",
            "Build",
        ]
        cols_keep = [c for c in cols_keep if c in df.columns]

        top = df.sort_values("anomaly_score", ascending=False).head(show_top)

        st.markdown("**Top anomalies**")
        editable = top[cols_keep].copy()
        editable.insert(0, "Select", False)

        edited = st.data_editor(
            editable,
            use_container_width=True,
            num_rows="fixed",
            disabled={c: True for c in editable.columns if c != "Select"},
            key=f"{key_prefix}-table",
        )

        selected_original_idxs = edited.index[edited["Select"]].tolist()
        if selected_original_idxs:
            pos = df.index.get_indexer([selected_original_idxs[0]])
            if len(pos) and pos[0] != -1:
                highlight_pos = int(pos[0])

    # --- PCA plot (full width), with optional driver arrows ---
    fig = plot_for_df(df, PCs, label_choice, highlight_pos=highlight_pos)

    if show_biplot and PCs.shape[1] >= 2 and pca is not None:
        # Use user-selected PCA arrow features; fall back to PCA_FEATURES if none selected
        arrow_feats = pca_arrow_features or PCA_FEATURES

        # 1) Global arrows from origin (if enabled)
        if show_global_pca_arrows:
            try:
                add_pca_loadings_3d(fig, pca, arrow_feats, scale=2.0)
            except Exception:
                pass

        # 2) Segment-anchored arrows near Low-FR and High-FR bands (if enabled)
        try:
            seg = make_fr_segments(df)  # "Low FR" / "Mid FR" / "High FR"

            if show_low_fr_arrows:
                low_mask = (seg == "Low FR").values
                if np.any(low_mask):
                    low_anchor = PCs[low_mask].mean(axis=0)
                    add_biplot_arrows_at_anchor_3d(
                        fig,
                        pca,
                        arrow_feats,
                        low_anchor,
                        scale=1.2,
                        color="green",
                        name_prefix="Low FR ",
                        showlegend=False,
                    )

            if show_high_fr_arrows:
                high_mask = (seg == "High FR").values
                if np.any(high_mask):
                    high_anchor = PCs[high_mask].mean(axis=0)
                    add_biplot_arrows_at_anchor_3d(
                        fig,
                        pca,
                        arrow_feats,
                        high_anchor,
                        scale=1.2,
                        color="red",
                        name_prefix="High FR ",
                        showlegend=False,
                    )
        except Exception:
            pass

    st.plotly_chart(fig, use_container_width=True, key=f"{key_prefix}-plot")

    # --- Segment Comparison + FR correlation (below PCA plot) ---
    if show_segment_compare:
        st.markdown("#### Segment Comparison: Low vs High FR")
        c1, c2 = st.columns(2)
        with c1:
            st.markdown("**Numeric drivers**")
            st.plotly_chart(
                segment_diff_numeric_bar(df),
                use_container_width=True,
                key=f"{key_prefix}-segnum",
            )
        with c2:
            st.markdown("**Categorical drivers**")
            st.plotly_chart(
                segment_diff_categorical_bar(df),
                use_container_width=True,
                key=f"{key_prefix}-segcat",
            )

        st.markdown("#### FR Correlation (High / Low)")
        st.plotly_chart(
            fr_correlation_heatmap(df),
            use_container_width=True,
            key=f"{key_prefix}-frcorr",
        )

    # --- NEW: Anomaly Influence Network ---
    if show_influence_network:
        st.markdown("#### Anomaly Influence Network")
        net_fig = anomaly_influence_network_figure(
            df,
            scores01,
            subset=influence_subset,
            q=0.95,
            top_k=influence_topk,
            edge_thresh=influence_edge_thresh,
            corr_method=influence_corr_method,
        )
        st.plotly_chart(net_fig, use_container_width=True, key=f"{key_prefix}-influence")

    # --- Per-selection “Why this run?” (bottom) ---
    if show_selection_why and highlight_pos is not None:
        st.markdown("#### Why this run?")
        st.plotly_chart(
            per_point_contribution_bar(df, highlight_pos),
            use_container_width=True,
            key=f"{key_prefix}-whybar",
        )


=========================================================================================================================================================================
=========================================================================================================================================================================


=========================================================================================================================================================================
=========================================================================================================================================================================



=========================================================================================================================================================================
=========================================================================================================================================================================




=========================================================================================================================================================================
=========================================================================================================================================================================



=========================================================================================================================================================================
=========================================================================================================================================================================
def _render_table_and_plot(
    df: pd.DataFrame,
    PCs: np.ndarray,
    scores01: np.ndarray,
    raw_scores: np.ndarray,
    method_label: str,
    key_prefix: str,
    pca,  # global PCA (for loadings)
):
    """
    Renders three visual perspectives for a given anomaly method:

      1) Storyboard:
         - Top anomalies table with row selection
         - PCA scatter with optional highlight
         - PCA loading arrows (global + segment-anchored)
         - Segment Comparison & FR correlation
         - Per-selection 'Why this run?' bar chart

      2) Cluster Heatmap:
         - Cluster-vs-feature heatmap in z-score space

      3) Feature Network:
         - Small network of top anomaly-driving features
    """
    df = df.copy()
    df["anomaly_score"] = scores01
    df["raw_anomaly_score"] = raw_scores

    st.markdown(f"### {method_label}")

    tab_story, tab_cluster, tab_network = st.tabs(
        ["Storyboard", "Cluster Heatmap", "Feature Network"]
    )

    # === 1) STORYBOARD TAB ===
    with tab_story:
        # --- Top anomalies: select a row to highlight on the plot ---
        highlight_pos = None
        if show_top > 0:
            cols_keep = [
                "Test_Run_ID",
                "FR",
                "Num_Tests",
                "total_init_time",
                "anomaly_score",
                "raw_anomaly_score",
                "Simulation_Host",
                "Simulation_Node",
                "Capability",
                "Script_File",
                "V",
                "s_number",
                "Build",
            ]
            cols_keep = [c for c in cols_keep if c in df.columns]

            top = df.sort_values("anomaly_score", ascending=False).head(show_top)

            st.markdown("**Top anomalies**")
            editable = top[cols_keep].copy()
            editable.insert(0, "Select", False)

            edited = st.data_editor(
                editable,
                use_container_width=True,
                num_rows="fixed",
                disabled={c: True for c in editable.columns if c != "Select"},
                key=f"{key_prefix}-table",
            )

            selected_original_idxs = edited.index[edited["Select"]].tolist()
            if selected_original_idxs:
                pos = df.index.get_indexer([selected_original_idxs[0]])
                if len(pos) and pos[0] != -1:
                    highlight_pos = int(pos[0])

        # --- PCA plot with optional highlight ---
        fig = plot_for_df(df, PCs, label_choice, highlight_pos=highlight_pos)

        # === Driver arrows overlays (global + low/high FR anchors) ===
        if show_biplot and PCs.shape[1] >= 2 and pca is not None:
            # 1) Global arrows from origin
            try:
                add_pca_loadings_3d(fig, pca, PCA_FEATURES, scale=2.0)
            except Exception:
                pass

            # 2) Segment-anchored arrows near Low-FR and High-FR bands
            try:
                seg = make_fr_segments(df)  # "Low FR" / "Mid FR" / "High FR"
                # Low-FR centroid
                low_mask = (seg == "Low FR").values
                if np.any(low_mask):
                    low_anchor = PCs[low_mask].mean(axis=0)
                    add_biplot_arrows_at_anchor_3d(
                        fig,
                        pca,
                        PCA_FEATURES,
                        low_anchor,
                        scale=1.2,
                        color="green",
                        name_prefix="Low FR ",
                        showlegend=False,
                    )
                # High-FR centroid
                high_mask = (seg == "High FR").values
                if np.any(high_mask):
                    high_anchor = PCs[high_mask].mean(axis=0)
                    add_biplot_arrows_at_anchor_3d(
                        fig,
                        pca,
                        PCA_FEATURES,
                        high_anchor,
                        scale=1.2,
                        color="red",
                        name_prefix="High FR ",
                        showlegend=False,
                    )
            except Exception:
                pass

        st.plotly_chart(fig, use_container_width=True, key=f"{key_prefix}-plot")

        # --- Segment Comparison + FR Correlation ---
        if show_segment_compare:
            c1, c2 = st.columns([2, 1])
            with c1:
                st.markdown("#### Segment Comparison: Low vs High FR")
                st.plotly_chart(
                    segment_diff_bar(df),
                    use_container_width=True,
                    key=f"{key_prefix}-segdiff",
                )
            with c2:
                st.markdown("#### FR Correlation")
                st.plotly_chart(
                    fr_correlation_heatmap(df),
                    use_container_width=True,
                    key=f"{key_prefix}-frcorr",
                )

        # --- Per-selection “Why this run?” ---
        if show_selection_why and highlight_pos is not None:
            st.markdown("#### Why this run?")
            st.plotly_chart(
                per_point_contribution_bar(df, highlight_pos),
                use_container_width=True,
                key=f"{key_prefix}-whybar",
            )

    # === 2) CLUSTER HEATMAP TAB ===
    with tab_cluster:
        st.markdown("#### Cluster-level feature patterns")
        st.plotly_chart(
            cluster_profile_heatmap(df, PCs, scores01),
            use_container_width=True,
            key=f"{key_prefix}-clusterheat",
        )

    # === 3) FEATURE NETWORK TAB ===
    with tab_network:
        # Use the most anomalous subset to focus the network
        n_sub = max(20, int(0.2 * len(df)))
        df_anom = df.sort_values("anomaly_score", ascending=False).head(n_sub)
        st.markdown("#### Relationships among top anomaly-driving features")
        st.plotly_chart(
            feature_influence_network_figure(df_anom),
            use_container_width=True,
            key=f"{key_prefix}-featnet",
        )


