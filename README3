F-35 anomaly detection
from plotly.subplots import make_subplots  # add near your imports at the top


def fr_feature_plot(
    df: pd.DataFrame,
    selected_features: list[str],
    mode: str = "2D",
) -> go.Figure:
    """
    Visualize Failure Rate (FR) as a function of up to 2 features.

    - 2D mode:
        * If 1 feature:
            - Bar chart of average FR by binned (numeric) or categorical values.
        * If 2 features:
            - Two side-by-side bar charts (one per feature).
    - 3D mode:
        * Requires exactly 2 features.
        * 3D scatter: x = feature1, y = feature2, z = FR (per run),
          colored by FR.
    """
    fig = go.Figure()

    if "FR" not in df.columns:
        fig.update_layout(
            title="FR not available",
            height=250,
            margin=dict(l=10, r=10, t=40, b=40),
        )
        return fig

    FR = df["FR"].astype(float)

    def is_numeric(series: pd.Series) -> bool:
        return np.issubdtype(series.dtype, np.number)

    # No features selected
    if not selected_features:
        fig.update_layout(
            title="Select 1 or 2 features to view their relationship to FR",
            height=200,
            margin=dict(l=10, r=10, t=40, b=40),
        )
        return fig

    # ------------------------ 3D MODE ------------------------
    if mode == "3D":
        if len(selected_features) != 2:
            fig.update_layout(
                title="3D FR plot requires exactly 2 selected features",
                height=220,
                margin=dict(l=10, r=10, t=40, b=40),
            )
            return fig

        f1, f2 = selected_features
        if f1 not in df.columns or f2 not in df.columns:
            fig.update_layout(
                title="Selected features not in DataFrame",
                height=220,
                margin=dict(l=10, r=10, t=40, b=40),
            )
            return fig

        s1 = df[f1]
        s2 = df[f2]

        # Encode categoricals as codes so we can place them on axes
        if not is_numeric(s1):
            s1_num = s1.astype("category").cat.codes.astype(float)
        else:
            s1_num = s1.astype(float)

        if not is_numeric(s2):
            s2_num = s2.astype("category").cat.codes.astype(float)
        else:
            s2_num = s2.astype(float)

        hovertext = [
            f"Test Run ID: {trid}<br>{f1}: {v1}<br>{f2}: {v2}<br>FR: {fr:.3f}"
            for trid, v1, v2, fr in zip(
                df.get("Test_Run_ID", df.index),
                s1,
                s2,
                FR,
            )
        ]

        fig.add_trace(
            go.Scatter3d(
                x=s1_num,
                y=s2_num,
                z=FR,
                mode="markers",
                marker=dict(
                    size=4,
                    color=FR,
                    colorscale="RdYlGn_r",  # low FR = green, high FR = red
                    colorbar=dict(title="FR"),
                ),
                hovertext=hovertext,
                hoverinfo="text",
            )
        )
        fig.update_layout(
            title=f"FR vs {f1} and {f2} (3D)",
            scene=dict(
                xaxis_title=f1,
                yaxis_title=f2,
                zaxis_title="FR",
            ),
            height=600,
            margin=dict(l=10, r=10, t=40, b=10),
        )
        return fig

    # ------------------------ 2D MODE ------------------------
    # Helper for a single feature: average FR by bin/category
    def avg_fr_by_feature(feature: str) -> tuple[list[str], np.ndarray]:
        s = df[feature]
        if is_numeric(s):
            try:
                # Bin into up to 10 quantile bins
                q = pd.qcut(
                    s.rank(method="first"),
                    10,
                    duplicates="drop",
                )
                grouped = df.assign(_bin=q).groupby("_bin")["FR"].mean()
                x_labels = [str(idx) for idx in grouped.index]
                y_vals = grouped.values
            except Exception:
                # Fallback: treat raw values (may be messy)
                grouped = df.groupby(feature)["FR"].mean()
                x_labels = [str(idx) for idx in grouped.index]
                y_vals = grouped.values
        else:
            grouped = df.groupby(feature)["FR"].mean()
            # Show top 15 by frequency / mean FR
            counts = df[feature].value_counts()
            top_vals = counts.index[:15]
            grouped = grouped.loc[grouped.index.intersection(top_vals)]
            grouped = grouped.sort_values(ascending=False)
            x_labels = [str(idx) for idx in grouped.index]
            y_vals = grouped.values

        return x_labels, y_vals

    # 2D, 1 feature
    if len(selected_features) == 1:
        f = selected_features[0]
        if f not in df.columns:
            fig.update_layout(
                title="Selected feature not in DataFrame",
                height=220,
                margin=dict(l=10, r=10, t=40, b=40),
            )
            return fig

        x, y = avg_fr_by_feature(f)
        fig.add_trace(go.Bar(x=x, y=y))
        fig.update_layout(
            title=f"Average FR by {f}",
            xaxis_title=f,
            yaxis_title="Average FR",
            height=400,
            margin=dict(l=10, r=10, t=40, b=80),
        )
        return fig

    # 2D, 2 features => two side-by-side bar charts
    f1, f2 = selected_features[:2]
    if f1 not in df.columns or f2 not in df.columns:
        fig.update_layout(
            title="Selected features not in DataFrame",
            height=220,
            margin=dict(l=10, r=10, t=40, b=40),
        )
        return fig

    x1, y1 = avg_fr_by_feature(f1)
    x2, y2 = avg_fr_by_feature(f2)

    fig = make_subplots(
        rows=1,
        cols=2,
        subplot_titles=[f"Average FR by {f1}", f"Average FR by {f2}"],
    )

    fig.add_trace(go.Bar(x=x1, y=y1, name=f1), row=1, col=1)
    fig.add_trace(go.Bar(x=x2, y=y2, name=f2), row=1, col=2)

    fig.update_xaxes(title_text=f1, row=1, col=1)
    fig.update_yaxes(title_text="Average FR", row=1, col=1)
    fig.update_xaxes(title_text=f2, row=1, col=2)
    fig.update_yaxes(title_text="Average FR", row=1, col=2)

    fig.update_layout(
        title="Average FR by selected features",
        showlegend=False,
        height=450,
        margin=dict(l=10, r=10, t=40, b=80),
    )
    return fig





=========================================================================================================================================================================
=========================================================================================================================================================================

def _render_table_and_plot(
    df: pd.DataFrame,
    PCs: np.ndarray,
    scores01: np.ndarray,
    raw_scores: np.ndarray,
    method_label: str,
    key_prefix: str,
    pca,                  # fitted PCA object (for loadings/arrows)
    pca_arrow_features: list[str],  # user-selected PCA features for arrows
):
    """
    Renders, for a given anomaly scoring method:

      1) Top anomalies table with row selection
      2) PCA scatter plot (3D) with optional highlight and PCA driver arrows
      3) Secondary tab set:
           - Storyboard:
               * Feature-wise FR viewer (2D/3D)
               * 'Why this run?' bar chart for selected run
           - Anomaly Influence Network:
               * Feature co-movement network among top-K features
    """
    df = df.copy()
    df["anomaly_score"] = scores01
    df["raw_anomaly_score"] = raw_scores

    st.markdown(f"### {method_label}")

    # -------------------------------------------------------------------------
    # Top anomalies table & selection
    # -------------------------------------------------------------------------
    highlight_pos: int | None = None
    show_top = st.session_state.get("show_top", 10)

    if show_top > 0:
        cols_keep = [
            "Test_Run_ID",
            "FR",
            "Num_Tests",
            "total_init_time",
            "anomaly_score",
            "raw_anomaly_score",
            "Simulation_Host",
            "Simulation_Node",
            "Capability",
            "Script_File",
            "V",
            "s_number",
            "Build",
        ]
        cols_keep = [c for c in cols_keep if c in df.columns]

        top = df.sort_values("anomaly_score", ascending=False).head(show_top)

        st.markdown("**Top anomalies**")
        editable = top[cols_keep].copy()
        editable.insert(0, "Select", False)

        edited = st.data_editor(
            editable,
            use_container_width=True,
            num_rows="fixed",
            disabled={c: True for c in editable.columns if c != "Select"},
            key=f"{key_prefix}-table",
        )

        # Map selected row back to original df index
        selected_original_idxs = edited.index[edited["Select"]].tolist()
        if selected_original_idxs:
            pos = df.index.get_indexer([selected_original_idxs[0]])
            if len(pos) and pos[0] != -1:
                highlight_pos = int(pos[0])

    # -------------------------------------------------------------------------
    # PCA plot (full width) with optional driver arrows
    # -------------------------------------------------------------------------
    label_choice = st.session_state.get("label_choice", "Failure Rate")

    fig = plot_for_df(
        df,
        PCs,
        label_choice=label_choice,
        highlight_pos=highlight_pos,
    )

    show_biplot = st.session_state.get("show_biplot", True)
    if show_biplot and PCs.shape[1] >= 2 and pca is not None:
        from typing import cast
        default_arrow_feats = cast(list[str], globals().get("PCA_FEATURES", []))
        arrow_feats = st.session_state.get("pca_arrow_features", pca_arrow_features) or default_arrow_feats

        show_global_pca_arrows = st.session_state.get("show_global_pca_arrows", True)
        show_low_fr_arrows = st.session_state.get("show_low_fr_arrows", True)
        show_high_fr_arrows = st.session_state.get("show_high_fr_arrows", True)

        # Global arrows from origin
        if show_global_pca_arrows:
            try:
                add_pca_loadings_3d(fig, pca, arrow_feats, scale=2.0)
            except Exception:
                pass

        # Segment-anchored arrows near Low-FR and High-FR bands
        try:
            seg = make_fr_segments(df)  # "Low FR" / "High FR"

            if seg is not None:
                if show_low_fr_arrows:
                    low_mask = (seg == "Low FR").values
                    if np.any(low_mask):
                        low_anchor = PCs[low_mask].mean(axis=0)
                        add_biplot_arrows_at_anchor_3d(
                            fig,
                            pca,
                            arrow_feats,
                            low_anchor,
                            scale=1.2,
                            color="green",
                            name_prefix="Low FR ",
                            showlegend=False,
                        )

                if show_high_fr_arrows:
                    high_mask = (seg == "High FR").values
                    if np.any(high_mask):
                        high_anchor = PCs[high_mask].mean(axis=0)
                        add_biplot_arrows_at_anchor_3d(
                            fig,
                            pca,
                            arrow_feats,
                            high_anchor,
                            scale=1.2,
                            color="red",
                            name_prefix="High FR ",
                            showlegend=False,
                        )
        except Exception:
            pass

    st.plotly_chart(fig, use_container_width=True, key=f"{key_prefix}-plot")

    # -------------------------------------------------------------------------
    # Secondary tabs: Storyboard | Anomaly Influence Network
    # -------------------------------------------------------------------------
    sub_story, sub_net = st.tabs(["Storyboard", "Anomaly Influence Network"])

    # --- Storyboard tab ------------------------------------------------------
    with sub_story:
        st.session_state["active_secondary"] = "Storyboard"

        show_segment_compare = st.session_state.get("show_segment_compare", True)
        show_selection_why = st.session_state.get("show_selection_why", True)

        # ---------- NEW Segment Comparison: Feature-wise FR viewer ----------
        if show_segment_compare:
            st.markdown("#### Feature-wise Failure Rate (FR) Viewer")

            # Limit feature choices to those in FEATURES_FOR_ANALYSIS and in df
            available_feats = [
                f for f in globals().get("FEATURES_FOR_ANALYSIS", [])
                if f in df.columns
            ]
            st.caption("Select up to 2 features to see how they relate to FR.")

            selected_features = st.multiselect(
                "Features",
                options=available_feats,
                default=available_feats[:1] if available_feats else [],
                max_selections=2,
                key=f"{key_prefix}-frfeat-select",
            )

            dim_choice = st.radio(
                "Plot dimension",
                options=["2D", "3D"],
                index=0,
                horizontal=True,
                key=f"{key_prefix}-frfeat-dim",
            )

            seg_fig = fr_feature_plot(
                df=df,
                selected_features=selected_features,
                mode=dim_choice,
            )
            st.plotly_chart(seg_fig, use_container_width=True, key=f"{key_prefix}-segplot")

        # Per-selection “Why this run?”
        if show_selection_why and highlight_pos is not None:
            st.markdown("#### Why this run?")
            st.plotly_chart(
                per_point_contribution_bar(df, highlight_pos),
                use_container_width=True,
                key=f"{key_prefix}-whybar",
            )

    # --- Anomaly Influence Network tab --------------------------------------
    with sub_net:
        st.session_state["active_secondary"] = "Anomaly Influence Network"

        show_influence_network = st.session_state.get("show_influence_network", True)
        if show_influence_network:
            subset = st.session_state.get("influence_subset", "Anomalous (top 5%)")
            top_k = st.session_state.get("influence_topk", 10)
            edge_thresh = st.session_state.get("influence_edge_thresh", 0.40)
            corr_method = st.session_state.get("influence_corr_method", "pearson")

            net_fig = anomaly_influence_network_figure(
                df,
                scores01,
                subset=subset,
                q=0.95,
                top_k=top_k,
                edge_thresh=edge_thresh,
                corr_method=corr_method,
            )
            st.plotly_chart(
                net_fig,
                use_container_width=True,
                key=f"{key_prefix}-influence",
            )


=========================================================================================================================================================================
=========================================================================================================================================================================



=========================================================================================================================================================================
=========================================================================================================================================================================

=========================================================================================================================================================================
=========================================================================================================================================================================
kinematic-classifier

# conftest.py (alternative)
import pytest, shutil
from pathlib import Path

@pytest.fixture()
def repo_data_files_with_fakes(tmp_path, monkeypatch):
    root = Path(__file__).resolve().parents[1]
    fake_src = root / "data" / "fake_data_files"
    real_dst = root / "my_pkg" / "data" / "data_files"

    backups = []
    real_dst.mkdir(parents=True, exist_ok=True)

    # backup any existing files, then copy fakes
    for f in real_dst.glob("*"):
        b = tmp_path / f.name
        shutil.copy2(f, b)
        backups.append((f, b))
    for f in fake_src.iterdir():
        if f.is_file():
            shutil.copy2(f, real_dst / f.name)

    yield real_dst  # tests run with fakes in place

    # restore previous contents
    for f in real_dst.glob("*"):
        f.unlink()
    for dst, backup in backups:
        shutil.copy2(backup, dst)

=========================================================================================================================================================================
=========================================================================================================================================================================




=========================================================================================================================================================================
=========================================================================================================================================================================
PG-35: Susceptibility Modeling

import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np

# Set the "Data Science Expert" aesthetic
sns.set_theme(style="whitegrid", context="talk")
palette = {"tag": "#e74c3c", "untag": "#3498db"} # Red for Tag (Action), Blue for Untag

def visualize_drone_dynamics(df):
    
    # Create a figure with a custom grid layout
    fig = plt.figure(figsize=(20, 16))
    gs = fig.add_gridspec(2, 2)
    
    # -------------------------------------------------------
    # 1. The Intercept Geometry (Polar Plot)
    # -------------------------------------------------------
    ax1 = fig.add_subplot(gs[0, 0], projection='polar')
    
    # Convert degrees to radians for polar plotting
    theta = np.radians(df['fd_pursuit_err'])
    r = df['fd_range']
    
    # Scatter plot
    # We create two masks to plot Tags on TOP of Untags
    mask_tag = df['outcome'] == 'tag'
    mask_untag = df['outcome'] == 'untag'
    
    ax1.scatter(theta[mask_untag], r[mask_untag], c=palette['untag'], 
                alpha=0.3, s=20, label='Untag', edgecolors='none')
    ax1.scatter(theta[mask_tag], r[mask_tag], c=palette['tag'], 
                alpha=0.9, s=50, label='Tag', edgecolors='k')
    
    ax1.set_theta_zero_location("N") # 0 degrees is UP (Nose of the drone)
    ax1.set_theta_direction(-1)      # Clockwise
    ax1.set_rlabel_position(90)
    ax1.set_title("Intercept Geometry:\nPursuit Error (Angle) vs Range (Radius)", pad=20)
    ax1.legend(loc='lower right', bbox_to_anchor=(1.3, 0.1))
    
    # -------------------------------------------------------
    # 2. The Feasibility Cliff (TTI Margin)
    # -------------------------------------------------------
    ax2 = fig.add_subplot(gs[0, 1])
    
    sns.kdeplot(data=df, x='fd_tti_margin', hue='outcome', 
                fill=True, common_norm=False, palette=palette, 
                alpha=0.5, linewidth=2, ax=ax2)
    
    # Add a vertical line at 0 (The theoretical physics wall)
    ax2.axvline(0, color='black', linestyle='--', linewidth=2, label='Physics Threshold (0)')
    
    ax2.set_title("The Feasibility Cliff: Time-To-Intercept Margin")
    ax2.set_xlabel("Steps Remaining - Steps Needed (Negative = Impossible)")
    ax2.set_ylabel("Density")
    ax2.legend()
    
    # -------------------------------------------------------
    # 3. Kinematic Phase Space (Range vs Closing Vel)
    # -------------------------------------------------------
    ax3 = fig.add_subplot(gs[1, 0])
    
    sns.scatterplot(data=df, x='fd_range', y='fd_closing_vel', hue='outcome',
                    palette=palette, alpha=0.6, s=60, ax=ax3)
    
    ax3.axhline(0, color='gray', linestyle='--') # Zero closing velocity line
    ax3.set_title("Kinematic Phase Space")
    ax3.set_xlabel("Range (meters)")
    ax3.set_ylabel("Closing Velocity (m/s)")
    
    # Annotate the "Kill Zone"
    ax3.text(x=df['fd_range'].min(), y=df['fd_closing_vel'].max(), 
             s="  KILL ZONE", color='darkred', weight='bold', verticalalignment='top')
    
    # -------------------------------------------------------
    # 4. Feature Correlation Matrix
    # -------------------------------------------------------
    ax4 = fig.add_subplot(gs[1, 1])
    
    # Select only our new engineering features
    cols = ['fd_range', 'fd_closing_vel', 'fd_los_rate', 
            'fd_pursuit_err', 'fd_aspect_angle', 'fd_speed_ratio', 'fd_tti_margin']
    
    corr = df[cols].corr()
    
    mask = np.triu(np.ones_like(corr, dtype=bool)) # Hide upper triangle
    sns.heatmap(corr, mask=mask, cmap='RdBu_r', vmax=1, vmin=-1, center=0,
                square=True, linewidths=.5, cbar_kws={"shrink": .5}, annot=True, fmt=".2f", ax=ax4)
    
    ax4.set_title("Feature Correlation Matrix (Multicollinearity Check)")
    
    plt.tight_layout()
    plt.show()

# Run the visualization
visualize_drone_dynamics(df)

=========================================================================================================================================================================
=========================================================================================================================================================================



=========================================================================================================================================================================
=========================================================================================================================================================================



=========================================================================================================================================================================
=========================================================================================================================================================================


=========================================================================================================================================================================
=========================================================================================================================================================================


=========================================================================================================================================================================
=========================================================================================================================================================================


=========================================================================================================================================================================
=========================================================================================================================================================================
Extras

- Anomaly Detection
def _render_table_and_plot(
    df: pd.DataFrame,
    PCs: np.ndarray,
    scores01: np.ndarray,
    raw_scores: np.ndarray,
    method_label: str,
    key_prefix: str,
    pca,  # global PCA (for loadings)
):
    """
    Renders three visual perspectives for a given anomaly method:

      1) Storyboard:
         - Top anomalies table with row selection
         - PCA scatter with optional highlight
         - PCA loading arrows (global + segment-anchored)
         - Segment Comparison & FR correlation
         - Per-selection 'Why this run?' bar chart

      2) Cluster Heatmap:
         - Cluster-vs-feature heatmap in z-score space

      3) Feature Network:
         - Small network of top anomaly-driving features
    """
    df = df.copy()
    df["anomaly_score"] = scores01
    df["raw_anomaly_score"] = raw_scores

    st.markdown(f"### {method_label}")

    tab_story, tab_cluster, tab_network = st.tabs(
        ["Storyboard", "Cluster Heatmap", "Feature Network"]
    )

    # === 1) STORYBOARD TAB ===
    with tab_story:
        # --- Top anomalies: select a row to highlight on the plot ---
        highlight_pos = None
        if show_top > 0:
            cols_keep = [
                "Test_Run_ID",
                "FR",
                "Num_Tests",
                "total_init_time",
                "anomaly_score",
                "raw_anomaly_score",
                "Simulation_Host",
                "Simulation_Node",
                "Capability",
                "Script_File",
                "V",
                "s_number",
                "Build",
            ]
            cols_keep = [c for c in cols_keep if c in df.columns]

            top = df.sort_values("anomaly_score", ascending=False).head(show_top)

            st.markdown("**Top anomalies**")
            editable = top[cols_keep].copy()
            editable.insert(0, "Select", False)

            edited = st.data_editor(
                editable,
                use_container_width=True,
                num_rows="fixed",
                disabled={c: True for c in editable.columns if c != "Select"},
                key=f"{key_prefix}-table",
            )

            selected_original_idxs = edited.index[edited["Select"]].tolist()
            if selected_original_idxs:
                pos = df.index.get_indexer([selected_original_idxs[0]])
                if len(pos) and pos[0] != -1:
                    highlight_pos = int(pos[0])

        # --- PCA plot with optional highlight ---
        fig = plot_for_df(df, PCs, label_choice, highlight_pos=highlight_pos)

        # === Driver arrows overlays (global + low/high FR anchors) ===
        if show_biplot and PCs.shape[1] >= 2 and pca is not None:
            # 1) Global arrows from origin
            try:
                add_pca_loadings_3d(fig, pca, PCA_FEATURES, scale=2.0)
            except Exception:
                pass

            # 2) Segment-anchored arrows near Low-FR and High-FR bands
            try:
                seg = make_fr_segments(df)  # "Low FR" / "Mid FR" / "High FR"
                # Low-FR centroid
                low_mask = (seg == "Low FR").values
                if np.any(low_mask):
                    low_anchor = PCs[low_mask].mean(axis=0)
                    add_biplot_arrows_at_anchor_3d(
                        fig,
                        pca,
                        PCA_FEATURES,
                        low_anchor,
                        scale=1.2,
                        color="green",
                        name_prefix="Low FR ",
                        showlegend=False,
                    )
                # High-FR centroid
                high_mask = (seg == "High FR").values
                if np.any(high_mask):
                    high_anchor = PCs[high_mask].mean(axis=0)
                    add_biplot_arrows_at_anchor_3d(
                        fig,
                        pca,
                        PCA_FEATURES,
                        high_anchor,
                        scale=1.2,
                        color="red",
                        name_prefix="High FR ",
                        showlegend=False,
                    )
            except Exception:
                pass

        st.plotly_chart(fig, use_container_width=True, key=f"{key_prefix}-plot")

        # --- Segment Comparison + FR Correlation ---
        if show_segment_compare:
            c1, c2 = st.columns([2, 1])
            with c1:
                st.markdown("#### Segment Comparison: Low vs High FR")
                st.plotly_chart(
                    segment_diff_bar(df),
                    use_container_width=True,
                    key=f"{key_prefix}-segdiff",
                )
            with c2:
                st.markdown("#### FR Correlation")
                st.plotly_chart(
                    fr_correlation_heatmap(df),
                    use_container_width=True,
                    key=f"{key_prefix}-frcorr",
                )

        # --- Per-selection “Why this run?” ---
        if show_selection_why and highlight_pos is not None:
            st.markdown("#### Why this run?")
            st.plotly_chart(
                per_point_contribution_bar(df, highlight_pos),
                use_container_width=True,
                key=f"{key_prefix}-whybar",
            )

    # === 2) CLUSTER HEATMAP TAB ===
    with tab_cluster:
        st.markdown("#### Cluster-level feature patterns")
        st.plotly_chart(
            cluster_profile_heatmap(df, PCs, scores01),
            use_container_width=True,
            key=f"{key_prefix}-clusterheat",
        )

    # === 3) FEATURE NETWORK TAB ===
    with tab_network:
        # Use the most anomalous subset to focus the network
        n_sub = max(20, int(0.2 * len(df)))
        df_anom = df.sort_values("anomaly_score", ascending=False).head(n_sub)
        st.markdown("#### Relationships among top anomaly-driving features")
        st.plotly_chart(
            feature_influence_network_figure(df_anom),
            use_container_width=True,
            key=f"{key_prefix}-featnet",
        )


