# ADD: helper to compute standardized effect sizes (Cohen's d on standardized features)
def _standardized_effects(Xz: np.ndarray, feature_names: list[str], idx_a: np.ndarray, idx_b: np.ndarray) -> pd.Series:
    """Return effect sizes for A vs B on standardized features (comparable across features)."""
    if idx_a.sum() == 0 or idx_b.sum() == 0:
        return pd.Series(dtype=float)
    mean_a = Xz[idx_a].mean(axis=0)
    mean_b = Xz[idx_b].mean(axis=0)
    # pooled std on already standardized features ~1; still compute robustly
    sd_a = Xz[idx_a].std(axis=0, ddof=1)
    sd_b = Xz[idx_b].std(axis=0, ddof=1)
    sd_p = np.sqrt(((sd_a ** 2) + (sd_b ** 2)) / 2.0)
    sd_p[sd_p == 0] = 1.0  # avoid divide-by-zero
    d = (mean_a - mean_b) / sd_p
    return pd.Series(d, index=feature_names).sort_values(ascending=False)

# ADD: pretty display names (collapse one-hot names like 'Simulation_Host_hostA' -> 'Simulation_Host=hostA')
def _pretty_feat_names(names: list[str]) -> list[str]:
    out = []
    for n in names:
        if "_" in n and any(n.startswith(prefix) for prefix in ["V_", "Simulation_Host_"]):
            base, val = n.split("_", 1)
            out.append(f"{base}={val}")
        else:
            out.append(n)
    return out

# ADD: simple insight bar-renderer
def _render_insight_bars(effects: pd.Series, title: str, k: int = 5):
    if effects.empty:
        st.info(f"No differences available for {title}.")
        return
    top_pos = effects.head(k)
    top_neg = effects.tail(k)
    # Combine for one chart (positive at top, negative at bottom)
    comb = pd.concat([top_pos, top_neg])
    disp = comb.copy()
    disp.index = _pretty_feat_names(list(disp.index))
    fig = go.Figure(go.Bar(
        x=disp.values,
        y=disp.index.tolist(),
        orientation="h",
        hovertemplate="%{y}: %{x:.2f}Ïƒ difference<extra></extra>"
    ))
    fig.update_layout(
        title=title,
        xaxis_title="Standardized difference (Ïƒ)",
        yaxis_title="Feature",
        height=350,
        margin=dict(l=10, r=10, t=40, b=10),
        bargap=0.2,
    )
    st.plotly_chart(fig, use_container_width=True)
=========================================================================================================================================================================
=========================================================================================================================================================================
# MODIFIED: return feature names and standardized matrix from fit
def fit_pca_scaled(X: np.ndarray, n_components: int = 3):
    scaler = StandardScaler()
    Xz = scaler.fit_transform(X)
    k = max(1, min(n_components, Xz.shape[0], Xz.shape[1]))
    pca = PCA(n_components=k)
    PCs = pca.fit_transform(Xz)
    return scaler, pca, Xz, PCs  # Xz reused for driver analysis

_, _, Xz, PCs = fit_pca_scaled(X.to_numpy(), n_components=3)
feature_names = list(X.columns)  # keep names aligned to Xz columns

=========================================================================================================================================================================
=========================================================================================================================================================================
# ADD: Insights panel â€“ explains what drives HIGH vs LOW (for continuous) or a chosen category (for categorical)
with st.expander("Why are these high/low? (Insights)", expanded=True):
    selected_label = LABEL_DICT[label_choice]

    if selected_label in CONTINUOUS_LABELS:
        # Split by quantiles: top 20% vs bottom 20%
        series = df[selected_label].astype(float)
        if series.notna().sum() >= 10:  # need a few data points
            q_low, q_high = series.quantile([0.2, 0.8])
            idx_high = series >= q_high
            idx_low  = series <= q_low

            effects = _standardized_effects(Xz, feature_names, idx_high.values, idx_low.values)

            # Visual overlays on plot: mark groups (halo markers) â€” optional but helpful
            # Save for downstream if you want to overlay; here we just show bars:
            _render_insight_bars(effects, title=f"Drivers of HIGH vs LOW {label_choice} (top 20% vs bottom 20%)")

            # Friendly chips
            if not effects.empty:
                pos = effects.head(3)
                neg = effects.tail(3)
                st.markdown(
                    "ðŸ”º **Higher in High group:** " + ", ".join([f"**{_pretty_feat_names([i])[0]}** (+{v:.2f}Ïƒ)" for i, v in pos.items()])
                )
                st.markdown(
                    "ðŸ”» **Lower in High group:** " + ", ".join([f"**{_pretty_feat_names([i])[0]}** ({v:.2f}Ïƒ)" for i, v in neg.items()])
                )
        else:
            st.info("Not enough data to compute high/low insights.")

    else:
        # Categorical: let user pick a category and compare to overall
        cats = df[selected_label].dropna().astype(str).unique().tolist()
        if not cats:
            st.info("No categories available.")
        else:
            cat_pick = st.selectbox(f"Explain differences for {label_choice}", cats, key=f"insights_{label_choice}")
            idx_cat = df[selected_label].astype(str).eq(cat_pick).values
            idx_all = ~np.isnan(Xz[:,0])  # everyone

            effects = _standardized_effects(Xz, feature_names, idx_cat, ~idx_cat)
            _render_insight_bars(effects, title=f"Drivers of {label_choice} = {cat_pick} vs Others")

            if not effects.empty:
                pos = effects.head(3)
                neg = effects.tail(3)
                st.markdown(
                    f"ðŸ§­ **More characteristic of `{cat_pick}`:** " + ", ".join([f"**{_pretty_feat_names([i])[0]}** (+{v:.2f}Ïƒ)" for i, v in pos.items()])
                )
                st.markdown(
                    f"ðŸ§­ **Less characteristic of `{cat_pick}`:** " + ", ".join([f"**{_pretty_feat_names([i])[0]}** ({v:.2f}Ïƒ)" for i, v in neg.items()])
                )


=========================================================================================================================================================================
=========================================================================================================================================================================
# OPTIONAL: Overlay halos for high/low (continuous case)
if selected_label in CONTINUOUS_LABELS:
    series = df[selected_label].astype(float)
    if series.notna().sum() >= 10:
        q_low, q_high = series.quantile([0.2, 0.8])
        idx_high = series >= q_high
        idx_low  = series <= q_low

        if PCs.shape[1] >= 3:
            fig.add_trace(go.Scatter3d(
                x=PCs[idx_high,0], y=PCs[idx_high,1], z=PCs[idx_high,2],
                mode="markers",
                marker=dict(size=6, symbol="circle-open", line=dict(width=2)),
                name=f"High {label_choice} (top 20%)",
                hoverinfo="skip",
                showlegend=True
            ))
            fig.add_trace(go.Scatter3d(
                x=PCs[idx_low,0], y=PCs[idx_low,1], z=PCs[idx_low,2],
                mode="markers",
                marker=dict(size=6, symbol="diamond-open", line=dict(width=2)),
                name=f"Low {label_choice} (bottom 20%)",
                hoverinfo="skip",
                showlegend=True
            ))
        else:
            fig.add_trace(go.Scatter(
                x=PCs[idx_high,0], y=PCs[idx_high,1],
                mode="markers",
                marker=dict(size=8, symbol="circle-open", line=dict(width=2)),
                name=f"High {label_choice} (top 20%)",
                hoverinfo="skip",
                showlegend=True
            ))
            fig.add_trace(go.Scatter(
                x=PCs[idx_low,0], y=PCs[idx_low,1],
                mode="markers",
                marker=dict(size=8, symbol="diamond-open", line=dict(width=2)),
                name=f"Low {label_choice} (bottom 20%)",
                hoverinfo="skip",
                showlegend=True
            ))


=========================================================================================================================================================================
=========================================================================================================================================================================


=========================================================================================================================================================================
=========================================================================================================================================================================


=========================================================================================================================================================================
=========================================================================================================================================================================


=========================================================================================================================================================================
=========================================================================================================================================================================
