def make_fr_segments(df: pd.DataFrame) -> pd.Series:
    """
    Segment runs into FR-based groups.

    Primary strategy (for discrete FR like {0, ..., 1}):
        - Low FR  : FR == min(FR) and close to 0
        - High FR : FR == max(FR) and close to 1
        - Mid FR  : all remaining values (0 < FR < 1)

    Fallback strategy (for more continuous FR):
        - Low FR  : FR <= 25th percentile
        - Mid FR  : 25th < FR < 75th percentile
        - High FR : FR >= 75th percentile

    Stores percentage breakdown and thresholds in st.session_state["FR_quartile_stats"].
    """
    if "FR" not in df.columns:
        return None

    fr = df["FR"].astype(float)
    fr_clean = fr.dropna()
    if fr_clean.empty:
        return None

    unique_vals = np.sort(fr_clean.unique())
    min_fr = float(unique_vals[0])
    max_fr = float(unique_vals[-1])

    seg = pd.Series(index=df.index, dtype=object)

    # ---- Strategy 1: Discrete FR with clear 0 / 1 extremes ----
    # Detect case like: {0, small decimals..., 1} where quantiles are useless.
    # Heuristics:
    #   - There is a value close to 0
    #   - There is a value close to 1
    #   - Number of unique FR values is small (e.g., <= 10)
    is_discrete_01 = (
        len(unique_vals) <= 10
        and np.isclose(min_fr, 0.0, atol=1e-6)
        and np.isclose(max_fr, 1.0, atol=1e-6)
    )

    if is_discrete_01:
        # Low FR = exactly the minimum (≈ 0), High FR = exactly the maximum (≈ 1)
        low_mask = np.isclose(fr, min_fr, atol=1e-6)
        high_mask = np.isclose(fr, max_fr, atol=1e-6)
        mid_mask = ~(low_mask | high_mask)

        seg[low_mask] = "Low FR"
        seg[high_mask] = "High FR"
        seg[mid_mask] = "Mid FR"

        strategy = "discrete_0_1"
        low_thr = min_fr
        high_thr = max_fr

    else:
        # ---- Strategy 2: Fallback to quartiles (more continuous FR) ----
        q1 = fr_clean.quantile(0.25)
        q3 = fr_clean.quantile(0.75)

        seg[fr <= q1] = "Low FR"
        seg[fr >= q3] = "High FR"
        seg[(fr > q1) & (fr < q3)] = "Mid FR"

        strategy = "quartiles"
        low_thr = float(q1)
        high_thr = float(q3)

    # --- Compute percentages in each segment ---
    total = len(seg)
    pct_low  = 100.0 * (seg == "Low FR").sum() / total
    pct_mid  = 100.0 * (seg == "Mid FR").sum() / total
    pct_high = 100.0 * (seg == "High FR").sum() / total

    # Store stats in session_state for optional display / debugging
    st.session_state["FR_quartile_stats"] = {
        "strategy": strategy,
        "Low FR %": round(pct_low, 2),
        "Mid FR %": round(pct_mid, 2),
        "High FR %": round(pct_high, 2),
        "Low threshold": round(low_thr, 6),
        "High threshold": round(high_thr, 6),
        "unique_FR_values": unique_vals.tolist(),
    }

    return seg






=========================================================================================================================================================================
=========================================================================================================================================================================
with st.sidebar:
    if "FR_quartile_stats" in st.session_state:
        st.subheader("FR Segmentation")
        stats = st.session_state["FR_quartile_stats"]
        st.write(f"Strategy: `{stats['strategy']}`")
        st.write(f"Low FR %:  {stats['Low FR %']}%  (FR ≤ {stats['Low threshold']})")
        st.write(f"High FR %: {stats['High FR %']}% (FR ≥ {stats['High threshold']})")
        st.write(f"Mid FR %:  {stats['Mid FR %']}%")





=========================================================================================================================================================================
=========================================================================================================================================================================



=========================================================================================================================================================================
=========================================================================================================================================================================

=========================================================================================================================================================================
=========================================================================================================================================================================

=========================================================================================================================================================================
=========================================================================================================================================================================




=========================================================================================================================================================================
=========================================================================================================================================================================

import matplotlib.pyplot as plt
from matplotlib.colors import ListedColormap

# Background colors: 0 = UNTAGGED (green), 1 = TAGGED (red)
cmap_bg = ListedColormap(["#81c784", "#e57373"])  # light green, light red

# Point colors (slightly darker)
point_colors = {
    "UNTAGGED": "#388e3c",  # darker green
    "TAGGED":   "#c62828",  # darker red
}

# Build a grid over the feature space
x_min, x_max = X[:, 0].min() - 1, X[:, 0].max() + 1
y_min, y_max = X[:, 1].min() - 1, X[:, 1].max() + 1

xx, yy = np.meshgrid(
    np.linspace(x_min, x_max, 300),
    np.linspace(y_min, y_max, 300),
)

grid = np.c_[xx.ravel(), yy.ravel()]
Z = clf_2d.predict(grid).reshape(xx.shape)  # 0 or 1 for each grid point

plt.figure(figsize=(8, 6))

# Decision regions
plt.contourf(xx, yy, Z, alpha=0.3, cmap=cmap_bg)

# Actual samples on top
for label, color in point_colors.items():
    mask = df["outcome"] == label
    plt.scatter(
        df.loc[mask, "target_distance"],
        df.loc[mask, "closing_speed"],
        s=20,
        c=color,
        label=label,
        edgecolor="k",
        linewidth=0.3,
        alpha=0.8,
    )

plt.xlabel("target_distance (ECEF Euclidean, e.g. meters)")
plt.ylabel("closing_speed (it_speed - runner_speed)")
plt.title("Decision tree boundary for TAGGED vs UNTAGGED")
plt.legend()
plt.tight_layout()
plt.show()


=========================================================================================================================================================================
=========================================================================================================================================================================
def _render_table_and_plot(
    df: pd.DataFrame,
    PCs: np.ndarray,
    scores01: np.ndarray,
    raw_scores: np.ndarray,
    method_label: str,
    key_prefix: str,
    pca,  # global PCA (for loadings)
):
    """
    Renders three visual perspectives for a given anomaly method:

      1) Storyboard:
         - Top anomalies table with row selection
         - PCA scatter with optional highlight
         - PCA loading arrows (global + segment-anchored)
         - Segment Comparison & FR correlation
         - Per-selection 'Why this run?' bar chart

      2) Cluster Heatmap:
         - Cluster-vs-feature heatmap in z-score space

      3) Feature Network:
         - Small network of top anomaly-driving features
    """
    df = df.copy()
    df["anomaly_score"] = scores01
    df["raw_anomaly_score"] = raw_scores

    st.markdown(f"### {method_label}")

    tab_story, tab_cluster, tab_network = st.tabs(
        ["Storyboard", "Cluster Heatmap", "Feature Network"]
    )

    # === 1) STORYBOARD TAB ===
    with tab_story:
        # --- Top anomalies: select a row to highlight on the plot ---
        highlight_pos = None
        if show_top > 0:
            cols_keep = [
                "Test_Run_ID",
                "FR",
                "Num_Tests",
                "total_init_time",
                "anomaly_score",
                "raw_anomaly_score",
                "Simulation_Host",
                "Simulation_Node",
                "Capability",
                "Script_File",
                "V",
                "s_number",
                "Build",
            ]
            cols_keep = [c for c in cols_keep if c in df.columns]

            top = df.sort_values("anomaly_score", ascending=False).head(show_top)

            st.markdown("**Top anomalies**")
            editable = top[cols_keep].copy()
            editable.insert(0, "Select", False)

            edited = st.data_editor(
                editable,
                use_container_width=True,
                num_rows="fixed",
                disabled={c: True for c in editable.columns if c != "Select"},
                key=f"{key_prefix}-table",
            )

            selected_original_idxs = edited.index[edited["Select"]].tolist()
            if selected_original_idxs:
                pos = df.index.get_indexer([selected_original_idxs[0]])
                if len(pos) and pos[0] != -1:
                    highlight_pos = int(pos[0])

        # --- PCA plot with optional highlight ---
        fig = plot_for_df(df, PCs, label_choice, highlight_pos=highlight_pos)

        # === Driver arrows overlays (global + low/high FR anchors) ===
        if show_biplot and PCs.shape[1] >= 2 and pca is not None:
            # 1) Global arrows from origin
            try:
                add_pca_loadings_3d(fig, pca, PCA_FEATURES, scale=2.0)
            except Exception:
                pass

            # 2) Segment-anchored arrows near Low-FR and High-FR bands
            try:
                seg = make_fr_segments(df)  # "Low FR" / "Mid FR" / "High FR"
                # Low-FR centroid
                low_mask = (seg == "Low FR").values
                if np.any(low_mask):
                    low_anchor = PCs[low_mask].mean(axis=0)
                    add_biplot_arrows_at_anchor_3d(
                        fig,
                        pca,
                        PCA_FEATURES,
                        low_anchor,
                        scale=1.2,
                        color="green",
                        name_prefix="Low FR ",
                        showlegend=False,
                    )
                # High-FR centroid
                high_mask = (seg == "High FR").values
                if np.any(high_mask):
                    high_anchor = PCs[high_mask].mean(axis=0)
                    add_biplot_arrows_at_anchor_3d(
                        fig,
                        pca,
                        PCA_FEATURES,
                        high_anchor,
                        scale=1.2,
                        color="red",
                        name_prefix="High FR ",
                        showlegend=False,
                    )
            except Exception:
                pass

        st.plotly_chart(fig, use_container_width=True, key=f"{key_prefix}-plot")

        # --- Segment Comparison + FR Correlation ---
        if show_segment_compare:
            c1, c2 = st.columns([2, 1])
            with c1:
                st.markdown("#### Segment Comparison: Low vs High FR")
                st.plotly_chart(
                    segment_diff_bar(df),
                    use_container_width=True,
                    key=f"{key_prefix}-segdiff",
                )
            with c2:
                st.markdown("#### FR Correlation")
                st.plotly_chart(
                    fr_correlation_heatmap(df),
                    use_container_width=True,
                    key=f"{key_prefix}-frcorr",
                )

        # --- Per-selection “Why this run?” ---
        if show_selection_why and highlight_pos is not None:
            st.markdown("#### Why this run?")
            st.plotly_chart(
                per_point_contribution_bar(df, highlight_pos),
                use_container_width=True,
                key=f"{key_prefix}-whybar",
            )

    # === 2) CLUSTER HEATMAP TAB ===
    with tab_cluster:
        st.markdown("#### Cluster-level feature patterns")
        st.plotly_chart(
            cluster_profile_heatmap(df, PCs, scores01),
            use_container_width=True,
            key=f"{key_prefix}-clusterheat",
        )

    # === 3) FEATURE NETWORK TAB ===
    with tab_network:
        # Use the most anomalous subset to focus the network
        n_sub = max(20, int(0.2 * len(df)))
        df_anom = df.sort_values("anomaly_score", ascending=False).head(n_sub)
        st.markdown("#### Relationships among top anomaly-driving features")
        st.plotly_chart(
            feature_influence_network_figure(df_anom),
            use_container_width=True,
            key=f"{key_prefix}-featnet",
        )


