# MODIFIED: new imports for stats
from sklearn.feature_selection import f_classif
from scipy.stats import spearmanr

# MODIFIED: helper – derive discrete groups from the selected label (bins for continuous; categories as-is)
def derive_groups(df: pd.DataFrame, selected_label: str) -> pd.Series:
    if selected_label in CONTINUOUS_LABELS:
        s = pd.to_numeric(df[selected_label], errors="coerce")
        q33, q66 = s.quantile([0.33, 0.66])
        def _bin(v):
            if pd.isna(v): return "NA"
            if v <= q33: return "Low"
            if v <= q66: return "Mid"
            return "High"
        return s.apply(_bin)
    else:
        return df[selected_label].astype(str).fillna("NA")

# MODIFIED: helper – compute per-group "signals" (top-k features with direction) for explanation
def compute_group_signals(df: pd.DataFrame, groups: pd.Series, top_k: int = 3) -> dict:
    """
    Returns dict[group_name] = list of strings like 'FR↑ (+2.1σ)', ranked by effect size / correlation.
    Uses numeric, interpretable features only.
    """
    # Choose a compact, interpretable set (avoid double-counting counts if FR & Num_Tests present)
    candidate_feats = [c for c in ["FR","Num_Tests","total_init_time","P","F","B","U"] if c in df.columns]
    X = df[candidate_feats].apply(pd.to_numeric, errors="coerce")
    Z = (X - X.mean()) / X.std(ddof=0).replace(0, np.nan)  # z-scores for direction/scale
    
    signals = {}
    if groups.nunique() <= 1:
        # Degenerate case
        for g in groups.unique():
            signals[g] = []
        return signals

    if groups.dtype == "object" or groups.nunique() <= 12:
        # Categorical grouping: one-vs-rest Cohen's d per feature as ranking
        for g in groups.unique():
            idx = (groups == g)
            sigs = []
            for f in candidate_feats:
                a = Z.loc[idx, f].dropna()
                b = Z.loc[~idx, f].dropna()
                if len(a) < 3 or len(b) < 3:
                    continue
                # Cohen's d (pooled)
                na, nb = len(a), len(b)
                sa2, sb2 = a.var(ddof=1), b.var(ddof=1)
                sp = np.sqrt(((na-1)*sa2 + (nb-1)*sb2) / max(na+nb-2, 1))
                if sp == 0 or np.isnan(sp): 
                    continue
                d = (a.mean() - b.mean()) / sp
                arrow = "↑" if d > 0 else "↓"
                sigs.append((abs(d), f"{f}{arrow} ({a.mean():+.1f}σ)"))
            sigs.sort(reverse=True, key=lambda x: x[0])
            signals[g] = [s for _, s in sigs[:top_k]]
    else:
        # Fallback (shouldn't hit here often), treat as categorical
        return compute_group_signals(df, groups.astype(str), top_k)

    # Global ranking as tiebreaker (optional): ANOVA F across groups – not shown, but improves stability
    try:
        y = pd.Categorical(groups).codes
        F_vals, _ = f_classif(X.fillna(0), y)
        F_rank = dict(zip(candidate_feats, F_vals))
        for g, lst in signals.items():
            lst.sort(key=lambda s: F_rank.get(s.split("↑")[0].split("↓")[0], 0), reverse=True)
            signals[g] = lst[:top_k]
    except Exception:
        pass

    return signals

=========================================================================================================================================================================
=========================================================================================================================================================================
# MODIFIED: update plot builder to accept groups & signals and inject them into hover text
def plot_for_df(df: pd.DataFrame, PCs: np.ndarray, selected_label_name: str, highlight_pos: int | None = None,
                groups: pd.Series | None = None, group_signals: dict | None = None) -> go.Figure:
    selected_label = LABEL_DICT[selected_label_name]
    scores = compute_anomaly_scores(PCs)
    is_3d = PCs.shape[1] >= 3

    if groups is None:
        groups = derive_groups(df, selected_label)
    if group_signals is None:
        group_signals = compute_group_signals(df, groups)

    # base hover fields
    base_cols = ["Test_Run_ID","FR","Num_Tests","total_init_time"]
    for c in base_cols:
        if c not in df.columns: df[c] = np.nan

    # Build per-point hover with signals for its group
    sig_for_row = groups.map(lambda g: ", ".join(group_signals.get(g, [])))
    hovertext_common = [
        f"Cluster: {grp}<br>Signals: {sig}<br>Test Run ID: {trid}<br>FR: {fr:.3f}<br>Total Tests: {nt}<br>Total Time: {tt}<br>Anomaly: {s:.3f}"
        for grp, sig, trid, fr, nt, tt, s in zip(groups, sig_for_row, df["Test_Run_ID"], df["FR"], df["Num_Tests"], df["total_init_time"], scores)
    ]

    # --- existing coloring logic remains unchanged; just replace hovertext=... with hovertext_common ---
    # For brevity, show one example branch; apply similarly in your existing branches:
    # (Inside your continuous-label branch, when you add the main scatter trace:)
    # fig.add_trace(go.Scatter3d(..., hovertext=hovertext_common, hoverinfo="text", ...))

    # ADD highlight overlay (unchanged) at the end ...
    # (keep your existing highlight code)
    # fig.update_layout(...) and return



=========================================================================================================================================================================
=========================================================================================================================================================================

# MODIFIED: in render_one(...), compute groups & signals once, pass to plot, and augment table with cluster/signals
groups = derive_groups(df, LABEL_DICT[label_choice])
group_signals = compute_group_signals(df, groups, top_k=3)

# ... build Top anomalies table
if show_top > 0:
    cols_keep = ["Test_Run_ID","FR","Num_Tests","total_init_time","anomaly_score",
                 "Simulation_Host","Simulation_Node","Capability","Script_File","V","s_number","Build"]
    cols_keep = [c for c in cols_keep if c in df.columns]
    top = df.sort_values("anomaly_score", ascending=False).head(show_top).copy()

    # MODIFIED: add cluster & signals columns for interpretability
    top["Cluster"] = groups.loc[top.index].values
    top["Signals"] = top["Cluster"].map(lambda g: ", ".join(group_signals.get(g, [])))

    st.markdown("**Top anomalies**")
    editable = top[["Cluster","Signals"] + cols_keep].copy()
    editable.insert(0, "Select", False)

    edited = st.data_editor(
        editable,
        use_container_width=True,
        num_rows="fixed",
        disabled={c: True for c in editable.columns if c != "Select"}
    )

    selected_original_idxs = edited.index[edited["Select"]].tolist()
    if selected_original_idxs:
        pos = df.index.get_indexer([selected_original_idxs[0]])
        if len(pos) and pos[0] != -1:
            highlight_pos = int(pos[0])

# MODIFIED: pass groups & group_signals so hover shows explanations
fig = plot_for_df(df, PCs, label_choice, highlight_pos=highlight_pos, groups=groups, group_signals=group_signals)
st.plotly_chart(fig, use_container_width=True)


=========================================================================================================================================================================
=========================================================================================================================================================================

# MODIFIED: inside your existing plot_for_df branches,
# replace previous `hovertext = ...` with the unified `hovertext_common`.
# Example (continuous + 3D branch):
fig = go.Figure(go.Scatter3d(
    x=PCs[:,0], y=PCs[:,1], z=PCs[:,2],
    mode="markers",
    hovertext=hovertext_common, hoverinfo="text",
    marker=marker
))

=========================================================================================================================================================================
=========================================================================================================================================================================


=========================================================================================================================================================================
=========================================================================================================================================================================


=========================================================================================================================================================================
=========================================================================================================================================================================


=========================================================================================================================================================================
=========================================================================================================================================================================
