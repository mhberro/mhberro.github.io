# NEW: utilities to compute "drivers" that explain groupings

DRIVER_NUMERIC_CANDIDATES = ["FR", "Num_Tests", "total_init_time", "P", "F", "B", "U"]

def _present_numeric_features(df: pd.DataFrame) -> list[str]:
    """Keep only driver numeric columns that are present in df."""
    return [c for c in DRIVER_NUMERIC_CANDIDATES if c in df.columns]

def _zscore_cols(df: pd.DataFrame, cols: list[str]) -> pd.DataFrame:
    arr = df[cols].astype(float)
    mu = arr.mean(axis=0)
    sd = arr.std(axis=0).replace(0, 1.0)
    return (arr - mu) / sd

def compute_continuous_drivers(df: pd.DataFrame, label: str, top_k: int = 8):
    """
    For continuous 'label', return:
    - corr_df: Pearson correlations between label and each numeric feature (sorted by |r|)
    - contrast_df: mean(z) in top quantile minus bottom quantile for each feature
    """
    feats = _present_numeric_features(df)
    feats_wo_label = [f for f in feats if f != label]

    if not feats_wo_label:
        return pd.DataFrame(), pd.DataFrame()

    # correlations (numeric) with the selected label
    corr = {}
    x = pd.to_numeric(df[label], errors="coerce")
    for f in feats_wo_label:
        y = pd.to_numeric(df[f], errors="coerce")
        valid = x.notna() & y.notna()
        if valid.sum() < 3:
            continue
        r = np.corrcoef(x[valid], y[valid])[0, 1]
        corr[f] = r
    corr_df = (pd.Series(corr, name="r")
               .reindex(feats_wo_label)
               .dropna()
               .to_frame()
               .assign(abs_r=lambda d: d["r"].abs())
               .sort_values("abs_r", ascending=False)
               .drop(columns="abs_r")
               .head(top_k))

    # high vs low quantile contrast on standardized features
    z = _zscore_cols(df, feats_wo_label)
    qhi = df[label].quantile(0.80)
    qlo = df[label].quantile(0.20)
    hi = z.loc[df[label] >= qhi].mean()
    lo = z.loc[df[label] <= qlo].mean()
    contrast = (hi - lo).to_frame("hi_minus_lo_z").sort_values("hi_minus_lo_z", ascending=False)
    contrast_df = contrast.head(top_k).append(contrast.tail(top_k))

    return corr_df, contrast_df

def compute_categorical_drivers(df: pd.DataFrame, label: str, top_groups: int = 12):
    """
    For categorical 'label', return a heatmap-ready DataFrame of
    group mean z-scores minus global mean for numeric features.
    """
    feats = _present_numeric_features(df)
    if not feats or label not in df.columns:
        return pd.DataFrame()

    # standardized features
    z = _zscore_cols(df, feats)
    z["__group__"] = df[label].astype(str)

    # restrict to most frequent groups to keep the heatmap readable
    top_labels = z["__group__"].value_counts().head(top_groups).index
    g = z[z["__group__"].isin(top_labels)]

    grp_means = g.groupby("__group__")[feats].mean()
    # since we z-scored globally, group means already reflect deviation vs global mean
    # reshape for heatmap (rows = groups, cols = features)
    return grp_means

def top_row_drivers(df: pd.DataFrame, idx: int, k: int = 2) -> str:
    """Return a compact 'Top_Drivers' string for a row using largest |z| across numeric features."""
    feats = _present_numeric_features(df)
    if not feats:
        return ""
    z = _zscore_cols(df, feats)
    if idx not in z.index:
        return ""
    row = z.loc[idx].abs().sort_values(ascending=False).head(k)
    pieces = []
    for f, val in row.items():
        sign = "+" if z.loc[idx, f] >= 0 else "−"
        pieces.append(f"{f}({sign}{abs(z.loc[idx, f]):.1f}σ)")
    return ", ".join(pieces)

=========================================================================================================================================================================
=========================================================================================================================================================================
# --- AFTER plotting fig and before/after the Top anomalies table, add driver visuals ---

st.markdown("### What’s driving this grouping?")

selected_key = LABEL_DICT[label_choice]

if selected_key in CONTINUOUS_LABELS:
    # CONTINUOUS: show correlations and hi-vs-lo contrasts
    corr_df, contrast_df = compute_continuous_drivers(df, selected_key, top_k=8)

    if not corr_df.empty:
        corr_fig = go.Figure(go.Bar(
            x=corr_df["r"].values,
            y=corr_df.index.tolist(),
            orientation="h",
            hovertemplate="%{y}: r=%{x:.3f}<extra></extra>"
        ))
        corr_fig.update_layout(
            title=f"Feature correlations with {selected_key}",
            xaxis_title="Pearson r",
            yaxis_title="Feature",
            height=400,
            margin=dict(l=10, r=10, t=40, b=10)
        )
        st.plotly_chart(corr_fig, use_container_width=True)

    if not contrast_df.empty:
        # Sort so positives at top, negatives at bottom
        contrast_df = contrast_df.sort_values("hi_minus_lo_z")
        con_fig = go.Figure(go.Bar(
            x=contrast_df["hi_minus_lo_z"].values,
            y=contrast_df.index.tolist(),
            orientation="h",
            hovertemplate="%{y}: Δz (hi–low)=%{x:.2f}<extra></extra>"
        ))
        con_fig.update_layout(
            title=f"High vs Low {selected_key}: feature contrast (Δz)",
            xaxis_title="Mean z-score (High quantile − Low quantile)",
            yaxis_title="Feature",
            height=400,
            margin=dict(l=10, r=10, t=40, b=10)
        )
        st.plotly_chart(con_fig, use_container_width=True)

else:
    # CATEGORICAL: show heatmap of group mean z-scores
    hm = compute_categorical_drivers(df, selected_key, top_groups=12)
    if not hm.empty:
        heat = go.Figure(data=go.Heatmap(
            z=hm.values,
            x=hm.columns.tolist(),
            y=hm.index.tolist(),
            zmid=0.0,
            colorscale="RdBu",
            hovertemplate="Group=%{y}<br>%{x}: z=%{z:.2f}<extra></extra>"
        ))
        heat.update_layout(
            title=f"Which features define each {selected_key} group? (mean z-score vs global)",
            xaxis_title="Feature",
            yaxis_title=selected_key,
            height=500,
            margin=dict(l=10, r=10, t=40, b=10)
        )
        st.plotly_chart(heat, use_container_width=True)


=========================================================================================================================================================================
=========================================================================================================================================================================
# (inside render_one, where you build Top anomalies)
if show_top > 0:
    cols_keep = ["Test_Run_ID","FR","Num_Tests","total_init_time","anomaly_score",
                 "Simulation_Host","Simulation_Node","Capability","Script_File","V","s_number","Build"]
    cols_keep = [c for c in cols_keep if c in df.columns]

    top = df.sort_values("anomaly_score", ascending=False).head(show_top).copy()

    # NEW: per-row short explanation of main drivers (largest |z| features)
    top["Top_Drivers"] = [
        top_row_drivers(df, idx, k=2) for idx in top.index
    ]

    st.markdown("**Top anomalies**")
    editable = top[["Top_Drivers"] + cols_keep].copy()
    editable.insert(0, "Select", False)

    edited = st.data_editor(
        editable,
        use_container_width=True,
        num_rows="fixed",
        disabled={c: True for c in editable.columns if c != "Select"}
    )

    selected_original_idxs = edited.index[edited["Select"]].tolist()
    if selected_original_idxs:
        pos = df.index.get_indexer([selected_original_idxs[0]])
        if len(pos) and pos[0] != -1:
            highlight_pos = int(pos[0])



=========================================================================================================================================================================
=========================================================================================================================================================================


=========================================================================================================================================================================
=========================================================================================================================================================================


=========================================================================================================================================================================
=========================================================================================================================================================================


=========================================================================================================================================================================
=========================================================================================================================================================================


=========================================================================================================================================================================
=========================================================================================================================================================================
