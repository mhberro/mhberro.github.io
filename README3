F-35 anomaly detection

from plotly.subplots import make_subplots  # ensure this import exists
import numpy as np
import plotly.graph_objects as go
import pandas as pd


def fr_feature_plot(
    df: pd.DataFrame,
    selected_features: list[str],
    mode: str = "2D",
    top_n: int = 10,
) -> go.Figure:
    """
    Visualize Failure Rate (FR) as a function of up to 2 features.

    - 2D mode:
        * If 1 feature:
            - Bar chart of average FR by raw feature value.
              Values are treated as categories -> equal spacing on the x-axis.
              Only top-N values (by highest average FR) are shown.
        * If 2 features:
            - Two side-by-side bar charts (one per feature), same rules.
    - 3D mode:
        * Requires exactly 2 features.
        * 3D scatter: x = feature1, y = feature2, z = FR (per run),
          colored by FR.
        * Categorical features are encoded as integers for plotting, but axes
          are labeled with the original category values.

    Parameters
    ----------
    top_n : int
        Number of top values (by highest average FR) to display per feature in 2D mode.
    """
    fig = go.Figure()

    if "FR" not in df.columns:
        fig.update_layout(
            title="FR not available",
            height=250,
            margin=dict(l=10, r=10, t=40, b=40),
        )
        return fig

    FR = df["FR"].astype(float)

    def is_numeric(series: pd.Series) -> bool:
        return np.issubdtype(series.dtype, np.number)

    # No features selected
    if not selected_features:
        fig.update_layout(
            title="Select 1 or 2 features to view their relationship to FR",
            height=200,
            margin=dict(l=10, r=10, t=40, b=40),
        )
        return fig

    # ------------------------ 3D MODE ------------------------
    if mode == "3D":
        if len(selected_features) != 2:
            fig.update_layout(
                title="3D FR plot requires exactly 2 selected features",
                height=220,
                margin=dict(l=10, r=10, t=40, b=40),
            )
            return fig

        f1, f2 = selected_features
        if f1 not in df.columns or f2 not in df.columns:
            fig.update_layout(
                title="Selected features not in DataFrame",
                height=220,
                margin=dict(l=10, r=10, t=40, b=40),
            )
            return fig

        s1 = df[f1]
        s2 = df[f2]

        # --- Encode feature 1 (categorical -> codes, numeric stays numeric) ---
        if not is_numeric(s1):
            cat1 = s1.astype("category")
            s1_num = cat1.cat.codes.astype(float)
            cats1 = list(cat1.cat.categories)
            tickvals_x = list(range(len(cats1)))
            ticktext_x = [str(c) for c in cats1]
        else:
            s1_num = s1.astype(float)
            tickvals_x = None
            ticktext_x = None

        # --- Encode feature 2 ---
        if not is_numeric(s2):
            cat2 = s2.astype("category")
            s2_num = cat2.cat.codes.astype(float)
            cats2 = list(cat2.cat.categories)
            tickvals_y = list(range(len(cats2)))
            ticktext_y = [str(c) for c in cats2]
        else:
            s2_num = s2.astype(float)
            tickvals_y = None
            ticktext_y = None

        hovertext = [
            f"Test Run ID: {trid}<br>{f1}: {v1}<br>{f2}: {v2}<br>FR: {fr:.3f}"
            for trid, v1, v2, fr in zip(
                df.get("Test_Run_ID", df.index),
                s1,
                s2,
                FR,
            )
        ]

        fig.add_trace(
            go.Scatter3d(
                x=s1_num,
                y=s2_num,
                z=FR,
                mode="markers",
                marker=dict(
                    size=4,
                    color=FR,
                    colorscale="RdYlGn_r",  # low FR = green, high FR = red
                    colorbar=dict(title="FR"),
                ),
                hovertext=hovertext,
                hoverinfo="text",
            )
        )

        # Configure axes so ticks show the original feature values
        scene_cfg = dict(
            xaxis_title=f1,
            yaxis_title=f2,
            zaxis_title="FR",
        )

        if tickvals_x is not None:
            scene_cfg["xaxis"] = dict(
                title=f1,
                tickmode="array",
                tickvals=tickvals_x,
                ticktext=ticktext_x,
            )
        if tickvals_y is not None:
            scene_cfg["yaxis"] = dict(
                title=f2,
                tickmode="array",
                tickvals=tickvals_y,
                ticktext=ticktext_y,
            )

        fig.update_layout(
            title=f"FR vs {f1} and {f2} (3D)",
            scene=scene_cfg,
            height=600,
            margin=dict(l=10, r=10, t=40, b=10),
        )
        return fig

    # ------------------------ 2D MODE ------------------------
    # Helper for a single feature: average FR by *raw* value, equal spacing,
    # and only top-N values (by highest average FR).
    def avg_fr_by_feature(feature: str) -> tuple[np.ndarray, list[str], np.ndarray]:
        s = df[feature]

        # Average FR per raw value
        grouped = df.groupby(feature)["FR"].mean()

        # Sort by FR descending: top-N values that are most failure-prone
        grouped_sorted = grouped.sort_values(ascending=False).head(top_n)

        labels = [str(idx) for idx in grouped_sorted.index]  # raw values as strings
        y_vals = grouped_sorted.values

        # Positions 0..n-1 => equal spacing on x-axis
        x_vals = np.arange(len(labels))
        return x_vals, labels, y_vals

    # 2D, 1 feature
    if len(selected_features) == 1:
        f = selected_features[0]
        if f not in df.columns:
            fig.update_layout(
                title="Selected feature not in DataFrame",
                height=220,
                margin=dict(l=10, r=10, t=40, b=40),
            )
            return fig

        x_vals, x_labels, y = avg_fr_by_feature(f)

        fig.add_trace(go.Bar(x=x_vals, y=y))

        fig.update_layout(
            title=f"Average FR by top-{top_n} {f} values (raw)",
            xaxis=dict(
                title=f,
                tickmode="array",
                tickvals=x_vals,
                ticktext=x_labels,
                tickangle=45,  # angled for readability
            ),
            yaxis=dict(title="Average FR"),
            height=400,
            margin=dict(l=10, r=10, t=40, b=80),
        )
        return fig

    # 2D, 2 features => two side-by-side bar charts
    f1, f2 = selected_features[:2]
    if f1 not in df.columns or f2 not in df.columns:
        fig.update_layout(
            title="Selected features not in DataFrame",
            height=220,
            margin=dict(l=10, r=10, t=40, b=40),
        )
        return fig

    x1_vals, x1_labels, y1 = avg_fr_by_feature(f1)
    x2_vals, x2_labels, y2 = avg_fr_by_feature(f2)

    fig = make_subplots(
        rows=1,
        cols=2,
        subplot_titles=[
            f"Average FR by top-{top_n} {f1}",
            f"Average FR by top-{top_n} {f2}",
        ],
    )

    fig.add_trace(go.Bar(x=x1_vals, y=y1, name=f1), row=1, col=1)
    fig.add_trace(go.Bar(x=x2_vals, y=y2, name=f2), row=1, col=2)

    fig.update_xaxes(
        title_text=f1,
        tickmode="array",
        tickvals=x1_vals,
        ticktext=x1_labels,
        tickangle=45,
        row=1,
        col=1,
    )
    fig.update_yaxes(title_text="Average FR", row=1, col=1)

    fig.update_xaxes(
        title_text=f2,
        tickmode="array",
        tickvals=x2_vals,
        ticktext=x2_labels,
        tickangle=45,
        row=1,
        col=2,
    )
    fig.update_yaxes(title_text="Average FR", row=1, col=2)

    fig.update_layout(
        title="Average FR by selected features (top-N values, raw labels)",
        showlegend=False,
        height=450,
        margin=dict(l=10, r=10, t=40, b=80),
    )
    return fig




=========================================================================================================================================================================
=========================================================================================================================================================================




=========================================================================================================================================================================
=========================================================================================================================================================================



=========================================================================================================================================================================
=========================================================================================================================================================================

=========================================================================================================================================================================
=========================================================================================================================================================================
kinematic-classifier

# conftest.py (alternative)
import pytest, shutil
from pathlib import Path

@pytest.fixture()
def repo_data_files_with_fakes(tmp_path, monkeypatch):
    root = Path(__file__).resolve().parents[1]
    fake_src = root / "data" / "fake_data_files"
    real_dst = root / "my_pkg" / "data" / "data_files"

    backups = []
    real_dst.mkdir(parents=True, exist_ok=True)

    # backup any existing files, then copy fakes
    for f in real_dst.glob("*"):
        b = tmp_path / f.name
        shutil.copy2(f, b)
        backups.append((f, b))
    for f in fake_src.iterdir():
        if f.is_file():
            shutil.copy2(f, real_dst / f.name)

    yield real_dst  # tests run with fakes in place

    # restore previous contents
    for f in real_dst.glob("*"):
        f.unlink()
    for dst, backup in backups:
        shutil.copy2(backup, dst)

=========================================================================================================================================================================
=========================================================================================================================================================================




=========================================================================================================================================================================
=========================================================================================================================================================================
PG-35: Susceptibility Modeling

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.ticker as ticker  # Import ticker for custom labels
import seaborn as sns

def plot_dogfight_final_units(df_analyzed):
    plt.figure(figsize=(12, 12))
    ax = plt.subplot(111, projection='polar')
    
    # 1. Orientation Setup
    ax.set_theta_zero_location("N") 
    ax.set_theta_direction(-1)
    
    # ---------------------------------------------------------
    # FORMATTING THE DISTANCE UNITS (New Addition)
    # ---------------------------------------------------------
    # This adds ' m' to every number on the radial circles
    ax.yaxis.set_major_formatter(ticker.FormatStrFormatter('%.0f m'))
    
    # Move the distance numbers to the 45-degree line so they don't 
    # overlap with the Head/Tail labels
    ax.set_rlabel_position(45)
    
    # ---------------------------------------------------------
    # DATA PREPARATION
    # ---------------------------------------------------------
    def get_target_speed(row):
        return row['runner_speed'][row['it_runner_index']]

    df_analyzed['target_speed_val'] = df_analyzed.apply(get_target_speed, axis=1)
    
    avg_it_speed = df_analyzed['it_speed'].mean()
    avg_runner_speed = df_analyzed['target_speed_val'].mean()
    
    groups = [
        {'label': 'Untag (Escaped)', 'color': 'blue', 'alpha': 0.2, 'data': df_analyzed[df_analyzed['outcome'] == 'untag']},
        {'label': 'Tag (Captured)',  'color': 'red',  'alpha': 0.7, 'data': df_analyzed[df_analyzed['outcome'] == 'tag']}
    ]
    
    # ---------------------------------------------------------
    # PLOTTING
    # ---------------------------------------------------------
    max_radius_found = 0
    
    for group in groups:
        subset = group['data']
        if subset.empty: continue
            
        theta = np.deg2rad(subset['relative_approach_angle'])
        
        # Check for distance column
        if 'distance_to_target' in subset.columns:
            r = subset['distance_to_target']
        else:
            r = np.random.uniform(5, 20, len(subset)) # Using larger numbers to show 'm' clearly
            
        if r.max() > max_radius_found:
            max_radius_found = r.max()

        # Vector Math for Headings
        target_headings = np.array([row['runner_heading'][row['it_runner_index']] 
                                    for _, row in subset.iterrows()])
        it_headings = subset['it_heading'].values
        rel_heading_rad = np.deg2rad(it_headings - target_headings)
        
        angle_diff = rel_heading_rad - theta
        u = np.cos(angle_diff)
        v = np.sin(angle_diff)
        
        ax.quiver(theta, r, u, v,
                  color=group['color'],
                  alpha=group['alpha'],
                  scale=30,
                  pivot='mid',
                  headwidth=3,
                  headlength=4,
                  label=group['label'])

    # ---------------------------------------------------------
    # LABELS
    # ---------------------------------------------------------
    
    # Set limit slightly higher than max data to fit everything
    ax.set_ylim(0, max_radius_found * 1.15)
    r_label_pos = max_radius_found * 1.25 
    
    plt.text(0, r_label_pos, "HEAD\n(Front)", ha='center', va='bottom', fontweight='bold', fontsize=11)
    plt.text(np.pi, r_label_pos, "TAIL\n(Rear)", ha='center', va='top', fontweight='bold', fontsize=11)
    plt.text(np.pi/2, r_label_pos, "Right Flank", ha='left', va='center', fontsize=10)
    plt.text(-np.pi/2, r_label_pos, "Left Flank", ha='right', va='center', fontsize=10)
    
    ax.plot(0, 0, marker='^', markersize=15, color='black', label='Target Runner')

    plt.title("Drone Dogfight Analysis: Approach Vectors", fontsize=16, y=1.15, fontweight='bold')
    
    # Speed Stats Box
    speed_text = (f"STATS:\n"
                  f"Avg It Speed: {avg_it_speed:.1f} m/s\n"
                  f"Avg Target Speed: {avg_runner_speed:.1f} m/s\n"
                  f"Delta: {'+' if avg_it_speed > avg_runner_speed else ''}{avg_it_speed - avg_runner_speed:.1f} m/s")
    
    plt.figtext(0.02, 0.95, speed_text, ha='left', va='top', fontsize=10, 
                bbox=dict(facecolor='white', alpha=0.9, edgecolor='gray', boxstyle='round,pad=0.5'))

    plt.legend(loc='upper right', bbox_to_anchor=(1.3, 1.1))
    plt.tight_layout()
    plt.show()

# plot_dogfight_final_units(df_analyzed)
=========================================================================================================================================================================
=========================================================================================================================================================================



=========================================================================================================================================================================
=========================================================================================================================================================================



=========================================================================================================================================================================
=========================================================================================================================================================================


=========================================================================================================================================================================
=========================================================================================================================================================================


=========================================================================================================================================================================
=========================================================================================================================================================================


=========================================================================================================================================================================
=========================================================================================================================================================================
Extras

- Anomaly Detection
def _render_table_and_plot(
    df: pd.DataFrame,
    PCs: np.ndarray,
    scores01: np.ndarray,
    raw_scores: np.ndarray,
    method_label: str,
    key_prefix: str,
    pca,  # global PCA (for loadings)
):
    """
    Renders three visual perspectives for a given anomaly method:

      1) Storyboard:
         - Top anomalies table with row selection
         - PCA scatter with optional highlight
         - PCA loading arrows (global + segment-anchored)
         - Segment Comparison & FR correlation
         - Per-selection 'Why this run?' bar chart

      2) Cluster Heatmap:
         - Cluster-vs-feature heatmap in z-score space

      3) Feature Network:
         - Small network of top anomaly-driving features
    """
    df = df.copy()
    df["anomaly_score"] = scores01
    df["raw_anomaly_score"] = raw_scores

    st.markdown(f"### {method_label}")

    tab_story, tab_cluster, tab_network = st.tabs(
        ["Storyboard", "Cluster Heatmap", "Feature Network"]
    )

    # === 1) STORYBOARD TAB ===
    with tab_story:
        # --- Top anomalies: select a row to highlight on the plot ---
        highlight_pos = None
        if show_top > 0:
            cols_keep = [
                "Test_Run_ID",
                "FR",
                "Num_Tests",
                "total_init_time",
                "anomaly_score",
                "raw_anomaly_score",
                "Simulation_Host",
                "Simulation_Node",
                "Capability",
                "Script_File",
                "V",
                "s_number",
                "Build",
            ]
            cols_keep = [c for c in cols_keep if c in df.columns]

            top = df.sort_values("anomaly_score", ascending=False).head(show_top)

            st.markdown("**Top anomalies**")
            editable = top[cols_keep].copy()
            editable.insert(0, "Select", False)

            edited = st.data_editor(
                editable,
                use_container_width=True,
                num_rows="fixed",
                disabled={c: True for c in editable.columns if c != "Select"},
                key=f"{key_prefix}-table",
            )

            selected_original_idxs = edited.index[edited["Select"]].tolist()
            if selected_original_idxs:
                pos = df.index.get_indexer([selected_original_idxs[0]])
                if len(pos) and pos[0] != -1:
                    highlight_pos = int(pos[0])

        # --- PCA plot with optional highlight ---
        fig = plot_for_df(df, PCs, label_choice, highlight_pos=highlight_pos)

        # === Driver arrows overlays (global + low/high FR anchors) ===
        if show_biplot and PCs.shape[1] >= 2 and pca is not None:
            # 1) Global arrows from origin
            try:
                add_pca_loadings_3d(fig, pca, PCA_FEATURES, scale=2.0)
            except Exception:
                pass

            # 2) Segment-anchored arrows near Low-FR and High-FR bands
            try:
                seg = make_fr_segments(df)  # "Low FR" / "Mid FR" / "High FR"
                # Low-FR centroid
                low_mask = (seg == "Low FR").values
                if np.any(low_mask):
                    low_anchor = PCs[low_mask].mean(axis=0)
                    add_biplot_arrows_at_anchor_3d(
                        fig,
                        pca,
                        PCA_FEATURES,
                        low_anchor,
                        scale=1.2,
                        color="green",
                        name_prefix="Low FR ",
                        showlegend=False,
                    )
                # High-FR centroid
                high_mask = (seg == "High FR").values
                if np.any(high_mask):
                    high_anchor = PCs[high_mask].mean(axis=0)
                    add_biplot_arrows_at_anchor_3d(
                        fig,
                        pca,
                        PCA_FEATURES,
                        high_anchor,
                        scale=1.2,
                        color="red",
                        name_prefix="High FR ",
                        showlegend=False,
                    )
            except Exception:
                pass

        st.plotly_chart(fig, use_container_width=True, key=f"{key_prefix}-plot")

        # --- Segment Comparison + FR Correlation ---
        if show_segment_compare:
            c1, c2 = st.columns([2, 1])
            with c1:
                st.markdown("#### Segment Comparison: Low vs High FR")
                st.plotly_chart(
                    segment_diff_bar(df),
                    use_container_width=True,
                    key=f"{key_prefix}-segdiff",
                )
            with c2:
                st.markdown("#### FR Correlation")
                st.plotly_chart(
                    fr_correlation_heatmap(df),
                    use_container_width=True,
                    key=f"{key_prefix}-frcorr",
                )

        # --- Per-selection “Why this run?” ---
        if show_selection_why and highlight_pos is not None:
            st.markdown("#### Why this run?")
            st.plotly_chart(
                per_point_contribution_bar(df, highlight_pos),
                use_container_width=True,
                key=f"{key_prefix}-whybar",
            )

    # === 2) CLUSTER HEATMAP TAB ===
    with tab_cluster:
        st.markdown("#### Cluster-level feature patterns")
        st.plotly_chart(
            cluster_profile_heatmap(df, PCs, scores01),
            use_container_width=True,
            key=f"{key_prefix}-clusterheat",
        )

    # === 3) FEATURE NETWORK TAB ===
    with tab_network:
        # Use the most anomalous subset to focus the network
        n_sub = max(20, int(0.2 * len(df)))
        df_anom = df.sort_values("anomaly_score", ascending=False).head(n_sub)
        st.markdown("#### Relationships among top anomaly-driving features")
        st.plotly_chart(
            feature_influence_network_figure(df_anom),
            use_container_width=True,
            key=f"{key_prefix}-featnet",
        )


