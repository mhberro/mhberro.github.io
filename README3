F-35 anomaly detection
def _render_table_and_plot(
    df: pd.DataFrame,
    PCs: np.ndarray,
    scores01: np.ndarray,
    raw_scores: np.ndarray,
    method_label: str,
    key_prefix: str,
    pca,                  # fitted PCA object (for loadings/arrows)
    pca_arrow_features: list[str],  # user-selected PCA features for arrows
):
    """
    Renders, for a given anomaly scoring method:

      1) Top anomalies table with row selection
      2) PCA scatter plot (3D) with optional highlight and PCA driver arrows
      3) Secondary tab set:
           - Storyboard:
               * Segment comparison (numeric + categorical)
               * FR representation heatmap (High/Low)
               * 'Why this run?' bar chart for selected run
           - Anomaly Influence Network:
               * Feature co-movement network among top-K features
    """
    df = df.copy()
    df["anomaly_score"] = scores01
    df["raw_anomaly_score"] = raw_scores

    st.markdown(f"### {method_label}")

    # -------------------------------------------------------------------------
    # Top anomalies table & selection
    # -------------------------------------------------------------------------
    highlight_pos: int | None = None
    show_top = st.session_state.get("show_top", 10)

    if show_top > 0:
        cols_keep = [
            "Test_Run_ID",
            "FR",
            "Num_Tests",
            "total_init_time",
            "anomaly_score",
            "raw_anomaly_score",
            "Simulation_Host",
            "Simulation_Node",
            "Capability",
            "Script_File",
            "V",
            "s_number",
            "Build",
        ]
        cols_keep = [c for c in cols_keep if c in df.columns]

        top = df.sort_values("anomaly_score", ascending=False).head(show_top)

        st.markdown("**Top anomalies**")
        editable = top[cols_keep].copy()
        editable.insert(0, "Select", False)

        edited = st.data_editor(
            editable,
            use_container_width=True,
            num_rows="fixed",
            disabled={c: True for c in editable.columns if c != "Select"},
            key=f"{key_prefix}-table",
        )

        # Map selected row back to original df index
        selected_original_idxs = edited.index[edited["Select"]].tolist()
        if selected_original_idxs:
            pos = df.index.get_indexer([selected_original_idxs[0]])
            if len(pos) and pos[0] != -1:
                highlight_pos = int(pos[0])

    # -------------------------------------------------------------------------
    # PCA plot (full width) with optional driver arrows
    # -------------------------------------------------------------------------
    label_choice = st.session_state.get("label_choice", "Failure Rate")

    fig = plot_for_df(
        df,
        PCs,
        label_choice=label_choice,
        highlight_pos=highlight_pos,
    )

    show_biplot = st.session_state.get("show_biplot", True)
    if show_biplot and PCs.shape[1] >= 2 and pca is not None:
        # Use user-selected PCA arrow features, falling back to PCA_FEATURES
        from typing import cast
        default_arrow_feats = cast(list[str], globals().get("PCA_FEATURES", []))
        arrow_feats = st.session_state.get("pca_arrow_features", pca_arrow_features) or default_arrow_feats

        show_global_pca_arrows = st.session_state.get("show_global_pca_arrows", True)
        show_low_fr_arrows = st.session_state.get("show_low_fr_arrows", True)
        show_high_fr_arrows = st.session_state.get("show_high_fr_arrows", True)

        # 1) Global arrows from origin
        if show_global_pca_arrows:
            try:
                add_pca_loadings_3d(fig, pca, arrow_feats, scale=2.0)
            except Exception:
                pass

        # 2) Segment-anchored arrows near Low-FR and High-FR bands
        try:
            seg = make_fr_segments(df)  # "Low FR" / "Mid FR" / "High FR"

            if seg is not None:
                # Low-FR centroid arrows
                if show_low_fr_arrows:
                    low_mask = (seg == "Low FR").values
                    if np.any(low_mask):
                        low_anchor = PCs[low_mask].mean(axis=0)
                        add_biplot_arrows_at_anchor_3d(
                            fig,
                            pca,
                            arrow_feats,
                            low_anchor,
                            scale=1.2,
                            color="green",
                            name_prefix="Low FR ",
                            showlegend=False,
                        )

                # High-FR centroid arrows
                if show_high_fr_arrows:
                    high_mask = (seg == "High FR").values
                    if np.any(high_mask):
                        high_anchor = PCs[high_mask].mean(axis=0)
                        add_biplot_arrows_at_anchor_3d(
                            fig,
                            pca,
                            arrow_feats,
                            high_anchor,
                            scale=1.2,
                            color="red",
                            name_prefix="High FR ",
                            showlegend=False,
                        )
        except Exception:
            pass

    st.plotly_chart(fig, use_container_width=True, key=f"{key_prefix}-plot")

    # -------------------------------------------------------------------------
    # Secondary tabs: Storyboard | Anomaly Influence Network
    # -------------------------------------------------------------------------
    sub_story, sub_net = st.tabs(["Storyboard", "Anomaly Influence Network"])

    # --- Storyboard tab ------------------------------------------------------
    with sub_story:
        st.session_state["active_secondary"] = "Storyboard"

        show_segment_compare = st.session_state.get("show_segment_compare", True)
        show_selection_why = st.session_state.get("show_selection_why", True)

        # Segment comparison + FR representation
        if show_segment_compare:
            st.markdown("#### Segment Comparison: Low vs High FR")

            c1, c2 = st.columns(2)
            with c1:
                st.markdown("**Numeric drivers**")
                st.plotly_chart(
                    segment_diff_numeric_bar(df),
                    use_container_width=True,
                    key=f"{key_prefix}-segnum",
                )
            with c2:
                st.markdown("**Categorical drivers**")
                st.plotly_chart(
                    segment_diff_categorical_bar(df),
                    use_container_width=True,
                    key=f"{key_prefix}-segcat",
                )

            st.markdown("#### FR Representation (High / Low)")
            st.plotly_chart(
                fr_correlation_heatmap(df),
                use_container_width=True,
                key=f"{key_prefix}-frcorr",
            )

        # Per-selection “Why this run?”
        if show_selection_why and highlight_pos is not None:
            st.markdown("#### Why this run?")
            st.plotly_chart(
                per_point_contribution_bar(df, highlight_pos),
                use_container_width=True,
                key=f"{key_prefix}-whybar",
            )

    # --- Anomaly Influence Network tab --------------------------------------
    with sub_net:
        st.session_state["active_secondary"] = "Anomaly Influence Network"

        show_influence_network = st.session_state.get("show_influence_network", True)
        if show_influence_network:
            subset = st.session_state.get("influence_subset", "Anomalous (top 5%)")
            top_k = st.session_state.get("influence_topk", 10)
            edge_thresh = st.session_state.get("influence_edge_thresh", 0.40)
            corr_method = st.session_state.get("influence_corr_method", "pearson")

            net_fig = anomaly_influence_network_figure(
                df,
                scores01,
                subset=subset,
                q=0.95,
                top_k=top_k,
                edge_thresh=edge_thresh,
                corr_method=corr_method,
            )
            st.plotly_chart(
                net_fig,
                use_container_width=True,
                key=f"{key_prefix}-influence",
            )


=========================================================================================================================================================================
=========================================================================================================================================================================

def render_one(path: Path):
    """
    Load one dataset, engineer features, run PCA + IF + LOF,
    and render three primary tabs:

        - Principal Component Analysis
        - Isolation Forest
        - Local Outlier Factor

    Each primary tab reuses `_render_table_and_plot`, which adds:
        - Top anomalies table
        - PCA visualization (with driver arrows)
        - Storyboard subtab (segment comparison, FR representation, Why-this-run)
        - Anomaly Influence Network subtab
    """
    try:
        # ---------------------------------------------------------------------
        # Load & feature engineering
        # ---------------------------------------------------------------------
        raw = load_csv(path)
        df = engineer_features(raw)

        # Build feature matrices
        X = build_features(df).to_numpy(dtype=float)      # raw numeric feature matrix
        Xz, _ = scale_features(df)                        # scaled version for anomaly models

        # ---------------------------------------------------------------------
        # PCA for visualization + PCA-based anomaly score (distance in PC space)
        # ---------------------------------------------------------------------
        scaler_viz, pca_viz, _, PCs = fit_pca_scaled(X, n_components=3)

        # Any function that turns PCs into an anomaly score (e.g., distance from mean)
        pca_dist_raw = compute_anomaly_scores(PCs)
        pca_s01 = normalize_scores(pca_dist_raw)

        # ---------------------------------------------------------------------
        # Isolation Forest
        # ---------------------------------------------------------------------
        if_contam = st.session_state.get("if_contam", 0.02)
        if_trees = st.session_state.get("if_trees", 300)

        _, if_raw = score_isolation_forest(
            Xz,
            contamination=if_contam,
            n_estimators=if_trees,
        )
        if_s01 = normalize_scores(if_raw)

        # ---------------------------------------------------------------------
        # Local Outlier Factor
        # ---------------------------------------------------------------------
        lof_k = st.session_state.get("lof_k", 20)

        _, lof_raw = score_lof(
            Xz,
            n_neighbors=lof_k,
        )
        lof_s01 = normalize_scores(lof_raw)

        # ---------------------------------------------------------------------
        # Page heading and primary method tabs
        # ---------------------------------------------------------------------
        st.subheader(f"{path.name} · Anomaly Analysis")

        tab_pca, tab_if, tab_lof = st.tabs(
            ["Principal Component Analysis", "Isolation Forest", "Local Outlier Factor"]
        )

        # --- PCA tab ---------------------------------------------------------
        with tab_pca:
            st.session_state["active_primary"] = "PCA"

            # Use whatever PCA features were previously selected in the sidebar
            pca_arrow_features = st.session_state.get(
                "pca_arrow_features",
                globals().get("PCA_FEATURES", []),
            )

            _render_table_and_plot(
                df=df,
                PCs=PCs,
                scores01=pca_s01,
                raw_scores=pca_dist_raw,
                method_label="Principal Component Analysis",
                key_prefix=f"{path.name}-PCA",
                pca=pca_viz,
                pca_arrow_features=pca_arrow_features,
            )

        # --- Isolation Forest tab -------------------------------------------
        with tab_if:
            st.session_state["active_primary"] = "Isolation Forest"

            pca_arrow_features = st.session_state.get(
                "pca_arrow_features",
                globals().get("PCA_FEATURES", []),
            )

            _render_table_and_plot(
                df=df,
                PCs=PCs,
                scores01=if_s01,
                raw_scores=if_raw,
                method_label="Isolation Forest",
                key_prefix=f"{path.name}-IF",
                pca=pca_viz,
                pca_arrow_features=pca_arrow_features,
            )

        # --- Local Outlier Factor tab ---------------------------------------
        with tab_lof:
            st.session_state["active_primary"] = "Local Outlier Factor"

            pca_arrow_features = st.session_state.get(
                "pca_arrow_features",
                globals().get("PCA_FEATURES", []),
            )

            _render_table_and_plot(
                df=df,
                PCs=PCs,
                scores01=lof_s01,
                raw_scores=lof_raw,
                method_label="Local Outlier Factor",
                key_prefix=f"{path.name}-LOF",
                pca=pca_viz,
                pca_arrow_features=pca_arrow_features,
            )

    except Exception as e:
        st.error(f"Failed to process {path.name}: {e}")


=========================================================================================================================================================================
=========================================================================================================================================================================



=========================================================================================================================================================================
=========================================================================================================================================================================

=========================================================================================================================================================================
=========================================================================================================================================================================
kinematic-classifier

# conftest.py (alternative)
import pytest, shutil
from pathlib import Path

@pytest.fixture()
def repo_data_files_with_fakes(tmp_path, monkeypatch):
    root = Path(__file__).resolve().parents[1]
    fake_src = root / "data" / "fake_data_files"
    real_dst = root / "my_pkg" / "data" / "data_files"

    backups = []
    real_dst.mkdir(parents=True, exist_ok=True)

    # backup any existing files, then copy fakes
    for f in real_dst.glob("*"):
        b = tmp_path / f.name
        shutil.copy2(f, b)
        backups.append((f, b))
    for f in fake_src.iterdir():
        if f.is_file():
            shutil.copy2(f, real_dst / f.name)

    yield real_dst  # tests run with fakes in place

    # restore previous contents
    for f in real_dst.glob("*"):
        f.unlink()
    for dst, backup in backups:
        shutil.copy2(backup, dst)

=========================================================================================================================================================================
=========================================================================================================================================================================




=========================================================================================================================================================================
=========================================================================================================================================================================
PG-35: Susceptibility Modeling

import pandas as pd
import numpy as np

def engineer_flight_dynamics_features(df):
    """
    Engineers aerospace-specific features for Drone Tag analysis.
    Assumes coordinates are Cartesian (ECEF or Local ENU).
    """
    
    # ---------------------------------------------------------
    # 1. Helper: Vector Construction
    # ---------------------------------------------------------
    def get_velocity_vector(speed, heading_deg, bearing_deg):
        """
        Estimates 3D velocity vector from speed and spherical angles.
        Note: We define Heading as Azimuth (0-360) and Bearing as Elevation for 3D context
        OR if Bearing is distinct, we use Heading as the 2D plane direction.
        
        Assumption for this code: 
        Heading = XY plane direction (0 = North/Y, 90 = East/X)
        Bearing = Pitch angle/Elevation (0 = Horizon)
        This is a standard simulation assumption if specific vector components aren't given.
        """
        heading_rad = np.radians(heading_deg)
        # Assuming 'bearing' acts as vertical flight path angle (gamma) here
        # If bearing is actually 2D direction, set pitch to 0.
        pitch_rad = np.radians(bearing_deg) 
        
        vx = speed * np.sin(heading_rad) * np.cos(pitch_rad)
        vy = speed * np.cos(heading_rad) * np.cos(pitch_rad)
        vz = speed * np.sin(pitch_rad)
        
        return np.array([vx, vy, vz])

    # Lists to store new features
    feat_range = []
    feat_closing_vel = []
    feat_los_rate = []
    feat_pursuit_error = []
    feat_aspect_angle = []
    feat_speed_ratio = []
    feat_tti_feasibility = []

    for index, row in df.iterrows():
        # ---------------------------------------------------------
        # 2. Extract State Vectors
        # ---------------------------------------------------------
        # Target Selection
        t_idx = row['it_runner_index']
        
        # Position Vectors (P)
        p_it = np.array(row['it_location']) # [x, y, z]
        p_target = np.array(row['runners_location'][t_idx]) # [x, y, z]
        
        # Velocity Vectors (V)
        # Using the helper to construct 3D vectors from scalar speed/heading
        v_it = get_velocity_vector(
            row['it_speed'], 
            row['it_heading'], 
            row['it_bearing']
        )
        
        v_target = get_velocity_vector(
            row['runner_speed'][t_idx], 
            row['runner_heading'][t_idx], 
            row['runner_bearing'][t_idx]
        )

        # ---------------------------------------------------------
        # 3. Calculate Relative Geometry
        # ---------------------------------------------------------
        # Range Vector (The "Line of Sight" Vector)
        r_vec = p_target - p_it
        dist = np.linalg.norm(r_vec) + 1e-6 # Avoid div/0
        
        # Unit Line of Sight Vector
        u_los = r_vec / dist
        
        # Relative Velocity Vector
        v_rel = v_it - v_target
        
        # ---------------------------------------------------------
        # 4. Compute Top 7 Features
        # ---------------------------------------------------------
        
        # F1: Slant Range
        feat_range.append(dist)
        
        # F2: Closing Velocity
        # Projection of It_Velocity onto LOS (How fast are we approaching?)
        # V_closing is positive when distance is decreasing.
        # Physics definition: - (dR/dt)
        # We project the relative velocity onto the LOS unit vector.
        closing_vel = np.dot(v_rel, u_los)
        feat_closing_vel.append(closing_vel)
        
        # F3: LOS Rate (Guidance Metric)
        # Magnitude of the cross product of Range and Rel_Vel, divided by R^2
        # Measures rotation of the sight-line.
        cross_prod_mag = np.linalg.norm(np.cross(r_vec, v_rel))
        los_rate = cross_prod_mag / (dist**2)
        feat_los_rate.append(los_rate)
        
        # F4: Pure Pursuit Error (Heading Error)
        # Angle between It_Velocity and LOS Vector
        # cos(theta) = (v . u) / (|v| |u|)
        v_it_mag = np.linalg.norm(v_it) + 1e-6
        dot_pursuit = np.dot(v_it, u_los)
        angle_pursuit_rad = np.arccos(np.clip(dot_pursuit / v_it_mag, -1.0, 1.0))
        feat_pursuit_error.append(np.degrees(angle_pursuit_rad))
        
        # F5: Aspect Angle
        # Angle between Target Velocity and LOS Vector
        # If 0 deg, target is running directly away (Tail Chase).
        # If 180 deg, target is flying at us (Head On).
        v_t_mag = np.linalg.norm(v_target) + 1e-6
        dot_aspect = np.dot(v_target, u_los)
        angle_aspect_rad = np.arccos(np.clip(dot_aspect / v_t_mag, -1.0, 1.0))
        feat_aspect_angle.append(np.degrees(angle_aspect_rad))
        
        # F6: Speed Ratio
        speed_ratio = row['it_speed'] / (row['runner_speed'][t_idx] + 1e-6)
        feat_speed_ratio.append(speed_ratio)
        
        # F7: TTI Feasibility
        # How many steps needed vs how many remain?
        if closing_vel > 0:
            steps_needed = dist / closing_vel
            margin = row['remaining_timesteps'] - steps_needed
        else:
            # If closing vel is negative, we are moving away. Infinite/Negative feasibility.
            margin = -999 
        feat_tti_feasibility.append(margin)

    # ---------------------------------------------------------
    # 5. Append to DataFrame
    # ---------------------------------------------------------
    df['fd_range'] = feat_range
    df['fd_closing_vel'] = feat_closing_vel
    df['fd_los_rate'] = feat_los_rate
    df['fd_pursuit_err'] = feat_pursuit_error
    df['fd_aspect_angle'] = feat_aspect_angle
    df['fd_speed_ratio'] = feat_speed_ratio
    df['fd_tti_margin'] = feat_tti_feasibility
    
    return df

# Example Usage:
# df_engineered = engineer_flight_dynamics_features(df)
# print(df_engineered[['outcome', 'fd_range', 'fd_closing_vel', 'fd_los_rate']].head())

=========================================================================================================================================================================
=========================================================================================================================================================================



=========================================================================================================================================================================
=========================================================================================================================================================================



=========================================================================================================================================================================
=========================================================================================================================================================================


=========================================================================================================================================================================
=========================================================================================================================================================================


=========================================================================================================================================================================
=========================================================================================================================================================================


=========================================================================================================================================================================
=========================================================================================================================================================================
Extras

- Anomaly Detection
def _render_table_and_plot(
    df: pd.DataFrame,
    PCs: np.ndarray,
    scores01: np.ndarray,
    raw_scores: np.ndarray,
    method_label: str,
    key_prefix: str,
    pca,  # global PCA (for loadings)
):
    """
    Renders three visual perspectives for a given anomaly method:

      1) Storyboard:
         - Top anomalies table with row selection
         - PCA scatter with optional highlight
         - PCA loading arrows (global + segment-anchored)
         - Segment Comparison & FR correlation
         - Per-selection 'Why this run?' bar chart

      2) Cluster Heatmap:
         - Cluster-vs-feature heatmap in z-score space

      3) Feature Network:
         - Small network of top anomaly-driving features
    """
    df = df.copy()
    df["anomaly_score"] = scores01
    df["raw_anomaly_score"] = raw_scores

    st.markdown(f"### {method_label}")

    tab_story, tab_cluster, tab_network = st.tabs(
        ["Storyboard", "Cluster Heatmap", "Feature Network"]
    )

    # === 1) STORYBOARD TAB ===
    with tab_story:
        # --- Top anomalies: select a row to highlight on the plot ---
        highlight_pos = None
        if show_top > 0:
            cols_keep = [
                "Test_Run_ID",
                "FR",
                "Num_Tests",
                "total_init_time",
                "anomaly_score",
                "raw_anomaly_score",
                "Simulation_Host",
                "Simulation_Node",
                "Capability",
                "Script_File",
                "V",
                "s_number",
                "Build",
            ]
            cols_keep = [c for c in cols_keep if c in df.columns]

            top = df.sort_values("anomaly_score", ascending=False).head(show_top)

            st.markdown("**Top anomalies**")
            editable = top[cols_keep].copy()
            editable.insert(0, "Select", False)

            edited = st.data_editor(
                editable,
                use_container_width=True,
                num_rows="fixed",
                disabled={c: True for c in editable.columns if c != "Select"},
                key=f"{key_prefix}-table",
            )

            selected_original_idxs = edited.index[edited["Select"]].tolist()
            if selected_original_idxs:
                pos = df.index.get_indexer([selected_original_idxs[0]])
                if len(pos) and pos[0] != -1:
                    highlight_pos = int(pos[0])

        # --- PCA plot with optional highlight ---
        fig = plot_for_df(df, PCs, label_choice, highlight_pos=highlight_pos)

        # === Driver arrows overlays (global + low/high FR anchors) ===
        if show_biplot and PCs.shape[1] >= 2 and pca is not None:
            # 1) Global arrows from origin
            try:
                add_pca_loadings_3d(fig, pca, PCA_FEATURES, scale=2.0)
            except Exception:
                pass

            # 2) Segment-anchored arrows near Low-FR and High-FR bands
            try:
                seg = make_fr_segments(df)  # "Low FR" / "Mid FR" / "High FR"
                # Low-FR centroid
                low_mask = (seg == "Low FR").values
                if np.any(low_mask):
                    low_anchor = PCs[low_mask].mean(axis=0)
                    add_biplot_arrows_at_anchor_3d(
                        fig,
                        pca,
                        PCA_FEATURES,
                        low_anchor,
                        scale=1.2,
                        color="green",
                        name_prefix="Low FR ",
                        showlegend=False,
                    )
                # High-FR centroid
                high_mask = (seg == "High FR").values
                if np.any(high_mask):
                    high_anchor = PCs[high_mask].mean(axis=0)
                    add_biplot_arrows_at_anchor_3d(
                        fig,
                        pca,
                        PCA_FEATURES,
                        high_anchor,
                        scale=1.2,
                        color="red",
                        name_prefix="High FR ",
                        showlegend=False,
                    )
            except Exception:
                pass

        st.plotly_chart(fig, use_container_width=True, key=f"{key_prefix}-plot")

        # --- Segment Comparison + FR Correlation ---
        if show_segment_compare:
            c1, c2 = st.columns([2, 1])
            with c1:
                st.markdown("#### Segment Comparison: Low vs High FR")
                st.plotly_chart(
                    segment_diff_bar(df),
                    use_container_width=True,
                    key=f"{key_prefix}-segdiff",
                )
            with c2:
                st.markdown("#### FR Correlation")
                st.plotly_chart(
                    fr_correlation_heatmap(df),
                    use_container_width=True,
                    key=f"{key_prefix}-frcorr",
                )

        # --- Per-selection “Why this run?” ---
        if show_selection_why and highlight_pos is not None:
            st.markdown("#### Why this run?")
            st.plotly_chart(
                per_point_contribution_bar(df, highlight_pos),
                use_container_width=True,
                key=f"{key_prefix}-whybar",
            )

    # === 2) CLUSTER HEATMAP TAB ===
    with tab_cluster:
        st.markdown("#### Cluster-level feature patterns")
        st.plotly_chart(
            cluster_profile_heatmap(df, PCs, scores01),
            use_container_width=True,
            key=f"{key_prefix}-clusterheat",
        )

    # === 3) FEATURE NETWORK TAB ===
    with tab_network:
        # Use the most anomalous subset to focus the network
        n_sub = max(20, int(0.2 * len(df)))
        df_anom = df.sort_values("anomaly_score", ascending=False).head(n_sub)
        st.markdown("#### Relationships among top anomaly-driving features")
        st.plotly_chart(
            feature_influence_network_figure(df_anom),
            use_container_width=True,
            key=f"{key_prefix}-featnet",
        )


